
### 392. 判断子序列
> 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。


```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n = s.size();
        int m = t.size();
        if (n > m) return false;
        int j = 0;
        for (int i = 0; i < m; i++) {
            if (t[i] == s[j]) {
                j++;
              
            }
        }
        return j == n;
    }
};
```
- 进一步思考： 当子串s特别长时，如何进行快速匹配
- 可以考虑在线性遍历的基础上，类似于KMP算法进行下一个位置记录，提高速度
  - 使用伪链表方式，记录每个位置下一个字符的位置(n*26的形式)
  - 为了保证结果可靠，在模
```c++
class Solution {
public:
	bool isSubsequence(string s, string t) {
		t.insert(t.begin(), ' '); // 初始化操作，使得后续可以计算起来 
		int len1 = s.size(), len2 = t.size();
		
		vector<vector<int> > dp(len2 , vector<int>(26, 0));

		for (char c = 'a'; c <= 'z'; c++) {
			int nextPos = -1; //表示接下来再不会出现该字符

			for (int i = len2 - 1; i>= 0; i--) {  //为了获得下一个字符的位置，要从后往前
				dp[i][c - 'a'] = nextPos;
				if (t[i] == c)
					nextPos = i; // 更新当前字符的最新位置
			}
		}

		int index = 0;
		for (char c : s) {
			index = dp[index][c - 'a'];
			if (index == -1)
				return false;
		}
		return true;

	}
};
```

### 115. 不同的子序列
> 给定一个字符串 s 和一个字符串 t ，**计算在 s 的子序列中 t 出现的个数**
> 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。

```
输入：s = "rabbbit", t = "rabbit"
输出：3
```
- 子序列为非连续的字符子串，可以通过动态规划的方式来进行求解：
  - 定义`dp[i][j]`  s串以i-1结尾的子序列和t串以j-1结尾的子序列匹配(子串匹配)的数量
  - 如果`s[i-1] == t[j-1]` 则`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]` 
    - `dp[i-1][j]`即以子串`s[i-1]`之前的串与t串进行匹配
  - 如果`s[i-1] ！= t[j-1]` 则`dp[i][j] = dp[i-1][j]` 
- 初始化： `dp[i][0] = 1` `dp[0][0] = 1`
- 关键点： **`动态规划分析`**
```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        int n = s.size();
        int m = t.size();
        int end = n;
        vector<vector<long long >> dp(n + 1, vector<long long>(m+1, 0));

        for (int i = 0; i <= n; i++) dp[i][0] = 1;
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s[i-1] == t[j-1]) {  
                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % INT_MAX;
                }
                else {
                    dp[i][j] = dp[i-1][j] % INT_MAX;
                }
            }
        }
        return dp[n][m];
    }
};
```


- 基于dfs的记忆化搜索，通过所有案例，但超时了。。。
- 从本质上理解： 动态规划是不会重复计算的递归搜索
```c++
class Solution {
public:
    vector<vector<int>> dp;
    int backTrack(string s, int beg, int end, string target, int index) {
        //cout << "beg" << beg << "end:" << end << "index " << index << endl;
        if (index == target.size()) {
            return 1;
        }
        if (beg > end || index > target.size()) {
            return 0;
        }
        if (dp[beg][index] != -1) {
            return dp[beg][index];
        }
        int ans = 0;
        for (int k = beg; k <= end; k++) {
            if (s[k] != target[index]) {
                continue;
            }
            else {
                if (dp[k + 1][index + 1] == -1)
                    dp[k+1][index+1] = backTrack(s, k + 1, end, target, index + 1);
                ans += dp[k+1][index+1];
            }
        }
        return ans;
    }
    int numDistinct(string s, string t) {
        int n = s.size();
        int m = t.size();
        int end = n;
        dp = vector<vector<int>>(n + 1, vector<int>(m+1, -1));
        for (int i = n - 1; i >= 0; i--) {
            if (s[i] == t.back()) {
                end = n - 1;
            }
        }
        if (end == n) {
            return 0;
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == t[0]) {
                ans+=backTrack(s, i, end, t, 0);
                break;
            }
        }
        return ans;
    }
};
```



### 300. 最长上升子序列 (LIS)
- 基础DP思路
  - 状态转移公式 `dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]`
  - 初始化：`dp[0]=0` 
  - 最后结果需要从dp中选取最大的值
  - 时间复杂度O(n^2), 空间复杂度 O(N)

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = 1;
        int ans = 1;
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = 1;
            for (int j = 0; j< i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            ans = max(dp[i], ans);
        } 
        return ans;
    }
};
```

- **贪心+二分搜索**
  - 要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。
  - 基于上面的贪心思路，维护一个数组 d[i]，表示长度为 ii 的最长上升子序列的末尾元素的最小值，用 \textit{len}len 记录目前最长上升子序列的长度，起始时 lenlen 为 11，d[1] = \textit{nums}[0]d[1]=nums[0]


```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> tail; // 定义不同长度的子序列的最大尾值
        int ans;
        tail.push_back(nums[0]);
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > tail.back()) {
                tail.push_back(nums[i]);
            }
            else {
                int left = 0;
                int right = tail.size() - 1;
                //cout << 'l' << left << 'r' << right << " "<< nums[i] <<endl;
                while(left < right) {
                    // int mid = left + (right - left)/2;
                    int mid = (left + right) / 2;
                    if (tail[mid] < nums[i]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
               tail[left] = nums[i];
            }
        }
        return tail.size();
    }
};
```


### 674. 最长连续递增序列
> 未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度

- **连续序列比非连续的子序列**要更容易处理， **直接遍历计数**即可
  - 注意对边界问题的处理， 每次上升即进行更新，而非出现非增再更新结果，以避免序列本身就单增或者结尾单增的情况
- 
```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        int beg = 1;
        int ans = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                beg++;
                ans = max(ans, beg);
            }
            else {
                beg = 1;
                //ans = max(ans, beg);
            }
        }
        return  ans;
    }
};
```






###  1143. 最长公共子序列 *
- 教科书式经典dp问题
> 给定两个字符串 text1 和 text2，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 公共子序列 ，返回 0 。
一个字符串的 子序列 是指这样一个新的字符串：它是由**原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串**

- 定义`dp[i][j]`表示**子串text1[0:i）和text2[0:j）的公共子序列的最长长度**
    - 状态转移公式： dp[i][j] = dp[i-1][j-1]+ 1  当text1[i] == text2[j]
      - `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1 = text1.size();
        int n2 = text2.size();
        vector<vector<int> > dp(n1 + 1, vector<int>(n2 + 1));
        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n1][n2];
    }
};
```


### 718. 最长重复子数组
> 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

- 滑窗方法解题，**分别移动A/B，调整两个数组的对齐位置，然后进行同位置元素对比，记录连续重复元素的个数**
  - 时间复杂度 O(N+M)*min(n,m) 
  - 空间复杂度 O(1)

```c++
class Solution {
public:
    int findRepeat(vector<int> A, vector<int> B, int addA, int addB, int len) {
        int res = 0;
        int k = 0;
        // 记录当前遍历下的最优结果
        for (int i = 0; i < len; i++) {
            if (A[addA + i] == B[addB + i])
                k++;
            else {
                k = 0;
            }
            res = max(res, k);
        }
        return res; 

    }
    int findLength(vector<int>& A, vector<int>& B) {
        int m = A.size();
        int n = B.size();
        int ans = 0;
        // 左移B数组
        // 当结果大于/等于当前对齐长度后break
        for (int i = 0; i < n - 1; i++) {
            int len = min(m, n - i);
            if (ans >= len)
                break;
            ans = max(findRepeat(A, B, 0, i, len), ans);
        }
        // 左移A数组
        // 当结果大于/等于当前对齐长度后break
        for (int i = 0; i < m - 1; i++) {
            int len = min(n, m - i);
            if (ans >= len)
                break;
            ans = max(findRepeat(A, B, i, 0, len), ans);
        }
        return ans;
    }
};
```

- **动态规划**解法
  - 定义`dp[i][j]` 表示A数组以i开始和B数组以j开始的子串的最大公共长度；
  - dp[i][j] = dp[i+1][j+1] + 1 if dp[i] == dp[j]; otherwise dp[i][j] = 0;
  - 最终结果为dp数组中的最大值
- 时间复杂度 `O(M*N)` 空间复杂度 `O(M*N)`
```c++
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int m = A.size();
        int n = B.size();
        int ans = 0;
        // 多增加一维，便于初始化
        vector<vector<int>> dp(m + 1, vector<int> (n + 1));
        //反向遍历 更新dp数组
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (A[i] == B[j]) {
                    dp[i][j] = dp[i + 1][j + 1] + 1;
                }
                else {
                    dp[i][j] = 0;
                }
                ans = max(ans, dp[i][j]);
            }
        }
        return ans;
    }
};
```
