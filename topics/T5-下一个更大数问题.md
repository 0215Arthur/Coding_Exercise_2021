
- [下一个更大数问题](#下一个更大数问题)
    - [496. 下一个更大元素 I](#496-下一个更大元素-i)
    - [503. 下一个更大元素 II](#503-下一个更大元素-ii)
    - [31. 下一个排列 [Medium]](#31-下一个排列-medium)
    - [556. 下一个更大元素 III](#556-下一个更大元素-iii)
    - [670. 最大交换](#670-最大交换)

# 下一个更大数问题
下一个更大数即`next greater number`，是典型的综合题目，面试中的高频题目。给出数组/字符串，让你计算当前状态的下一个更大数的状态，如何通过合理的对比和遍历逻辑得到下一个状态是题目的关键设计点。  

目前leetcode中主要涉及相关的两类题目：
- 给出数组，计算每个元素的下一个更大数 (使用单调栈进行解题)
- 给出正整数/字符串，计算紧邻的下一个更大的排列 (借助递增对的寻找进行解题)

---------

### 496. 下一个更大元素 I
> 两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。
请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1


- next greater 问题
- **一般使用单调栈进行解决** [LC739.每日温度]解题一致
  - 从栈底到栈顶单调递减**单调递减栈**；单调栈保存数组索引，当遇到比当前栈顶元素大的值时进行出栈操作，并更新结果
  - 本题涉及两个数组，需要使用哈希表来进行一个结果索引的映射
- 时间复杂度  O(N) 空间复杂度 O(N)


```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> map1;
        stack<int> st;
        vector<int> res(nums1.size(),-1);
        for (int i = 0; i < nums1.size(); i++) {
            map1[nums1[i]] = i;
        }
    
        for (int i = 0; i < nums2.size(); i++) {
            while (!st.empty() && nums2[st.top()] < nums2[i]) {
                if (map1.count(nums2[st.top()]) > 0) {
                    int index = map1[nums2[st.top()]];
                    res[index] = nums2[i];
                }
                st.pop();
            }
            st.push(i);
        }
        return res;
    }
};
```
### 503. 下一个更大元素 II
>**一个循环数组**（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

```
输入: [1,2,1]
输出: [2,-1,2]
```
- 与[LC496]的主要区别在于循环数组，使得元素可以双向对比
- 对该题进行简单转换，将数组进行二倍展开，使得每个元素可以与右侧元素进行重复对比；
  - 使用取模操作进行元素拓展访问
  - 只需要添加一点小改动即可
- 时间复杂度 O(N)  空间复杂度 O(N)
- 关键点： **`单调栈 + 循环数组访问`**

```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> res(nums.size(), -1);
        stack<int> st;
        int n = nums.size();
        // 对循环数组进行展开， 通过取模操作进行循环访问
        for (int i = 0; i < 2*n; i++) {
            while (!st.empty() && nums[st.top()] < nums[i % n]) {
                res[st.top()] = nums[i % n];
                st.pop();
            }
            st.push(i%n);
        }
        return res;
    }
};
```

-----------
- 主要思路：
  - 寻找递增对
  - 进行高低位交互和低位升序排列处理
  
### 31. 下一个排列 [Medium]

- 算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列
> 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465

> 还希望**下一个数增加的幅度尽可能的小**，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求:

1. 在尽可能靠右的低位进行交换，需要从后向前查找
2. 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
3. 将「大数」换到前面后，**需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列**。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列

- 关键两个步骤： 低位交换 和 后序序列的翻转
  - 低位交换： 找到相邻的< 组合， 
```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int length = nums.size();
        if (length <= 1)
            return;
        int p1 = length - 2;
        int p2 = length - 1;
        int tmp = length - 1;
        // 寻找低位
        while (p1 >= 0 && nums[p1] >= nums[p1 + 1]) {
            p1--;
        }
        // 后序元素跟低位进行交换
        if (p1 >= 0) {
            // 寻找后面第一个大于 低位的元素
            while (tmp >= 0 && nums[p1] >= nums[tmp]) {
                tmp--;
            }
            swap(nums[tmp], nums[p1]);
        }
        // 翻转后面的序列
        reverse(nums.begin() + p1 + 1, nums.end());
    }
};
```



### 556. 下一个更大元素 III 
> 正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。
> 返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1

- 与[LC31.下一个排列]做法一致，区别在于此处输入为32位正数，翻转计算后**可能存在溢出**
  - s1. 正整数转 string
  - s2. 寻找低位 [left < left + 1]； 若不存在低位，说明木的结果
  - s3. 存在低位： 则进行从个位开始搜索大于低位数字的首个值， 然后进行交换
  - s4. 为了保证是下一个紧邻的元素，**将低位后面的数字进行反序** （在前面的搜索过程中已经确保了这些部分是降序的，反序后的得到的值才是正确值）
- 特殊情况处理：
  - 最后需要添加对**溢出情况的处理**
- 时间复杂度 O(N) 空间复杂度 O(N)

```c++
class Solution {
public:
    int nextGreaterElement(int n) {
        string s = to_string(n);
        if (s.size() <= 1) return -1;
        int p2 = s.size() - 2;
        // 寻找左  < left
        while (p2 >= 0 && s[p2 + 1] <= s[p2]) {
            p2--;
        }
        if (p2 < 0) {
            return -1;
        }
        int t = s.size() - 1;
        // 翻转后序的部分：
        while (t >= 0 && s[t] <= s[p2]) {
            t--;
        }
        swap(s[p2], s[t]);
        reverse(s.begin() + p2 + 1, s.end());
        long val = stol(s);
        if (val > INT_MAX || val <= n) return -1;
        return val;
    }
};
```
------
- 与传统的next greater number有一定差异，但也有一定相通之处。
### 670. 最大交换
> 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。

```
输入: 2736
输出: 7236
解释: 交换数字2和数字7。
```
- 与[LC37.下一个排列]有相似之处，但细节上差异还挺大
- 本题也是要找到**高位上的最小值和低位上的最大值**，进行交换，但是需要注意的是计算过程是相对的
  - 在实现上通过辅助数组巧妙地完成这一寻找：
  - s1. 从低位到高位进行遍历， 确定**每个位置上从低到高的最大取值** （用辅助数组进行记录）
  - s2. 从高向低遍历，判断当前位置是否可以进行交换得到最大取值(通过上一步的辅助数组进行判断)； 若出现这种情况，直接进行交换即可得到结果

> 核心思想：**把尽可能低位的最大数字与尽可能高位的小数字交换**
1. 先从低位往高位遍历，保存每一位经过交换能得到的最大值的下标
2. 再从高位往低位遍历，直到某一位小于该位可以取到的最大值，上一步保存了该位置最大值的下标，交换即可


```c++
class Solution {
public:
    int maximumSwap(int num) {
        string s = to_string(num);
        vector<int> tmp(s.size()); //记录各个位置上的最大值
        int _m = s.size() - 1;
        for (int i = s.size() - 1; i >= 0; i--) {
            // 从低位到高位记录每个位置上的可能的最大取值
            if (s[i] > s[_m]) _m = i;
            tmp[i] = _m; 
        }
        // 然后从高位到低位进行遍历 对首个位置最大取值在低位的元素进行交换
        for (int i = 0; i < s.size(); i++) {
            if (s[tmp[i]] != s[i]) {
                swap(s[i], s[tmp[i]]);
                break;
            }
        }
        return stoi(s);
    }
};
```


