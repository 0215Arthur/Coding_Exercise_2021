
[TOC]
## 动态规划




### 70. 爬楼梯问题
- 递归公式：f(n)=f(n-1)+f(n-2) 递归解法会超时
- 使用简单的动态规划解决
- 或者利用上面的递归公式的通项公式来直接求解

```
class Solution {
public:
    int climbStairs(int n) {
        if(n<=1){
            return 1;
        }
       
        return climbStairs(n-1)+climbStairs(n-2);

    }
};
```


```
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+1);
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<n+1;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];

    }
};
```
**这种写法时间复杂度为O(n) 空间复杂度为O(n)，可以做进一步优化**： 空间复杂度优化到O(1)
```
class Solution {
public:
    int climbStairs(int n) {
        int p=0;
        int q=0;
        int r=1;
        for(int i=0;i<n;i++){
            p=q;
            q=r;
            r=q+p;

        }
        return r;

    }
};
```


### 121. 买卖股票的最佳时机

- 计算最大差值，如下所示一次遍历，记录当前最小值并计算差值。
- 时间复杂度O(n) 空间复杂度O(1)

```class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minprice=INT_MAX;
        int maxprofit=0;
        for(int i=0;i<prices.size();i++){
            if(prices[i]<minprice){
                minprice=prices[i];
            }else if(prices[i]-minprice>maxprofit){
                maxprofit=prices[i]-minprice;
            }
        }
        return maxprofit;

    }
};
```


### 53. 最大子序和
- 动态规划求解 **学习掌握这种节省空间的变量管理写法**
    - f(i)=max{f(i-1)+ai,ai} 状态转移公式 f(i)即表示以第i个数字结尾的子序列的最大值
    - 时间复杂度为： O(n) 空间复杂度O(1)

```class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //vector<int> res(nums.size());
        int pre=nums[0];
        int maxans=nums[0];
        for(int i =1; i<nums.size();i++){
            pre=max(pre+nums[i],nums[i]);
            maxans=max(pre,maxans);
        }
        return maxans;

    }
};
```

- 贪心算法: 从左到右遍历，计算和值，保留最大值；当和值小于0时，当前和值归0； 本质上仍然是DP算法
- **后续编程中，首先考虑边界情况(输入为空的情况)**
![avatar](./53-greedy.png)
```class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //vector<int> res(nums.size());
        if(nums.size()==0) return INT_MIN;  
        int sum=0;
        int maxans=INT_MIN;
        for(int i =0; i<nums.size();i++){
            sum+=nums[i]; 
            maxans=max(sum,maxans);
            if(sum<0){
                sum=0;
            }
        }
        return maxans;
    }
};
```

-  **分治解法**， 定义线段树，对于一个区间[l,r],定义中点$m=(l+r)/2$，分治计算[l,m]和[m+1,r]两段
    - 利用线段树来计算，对于线段[l,r]
    - lSum 表示 [l, r][l,r] 内以 l **为左端点的最大子段和**
    rSum 表示 [l, r][l,r] 内以 r **为右端点的最大子段和**
    mSum 表示 [l, r][l,r] 内的最大子段和
    iSum 表示 [l, r][l,r] 的**区间和**
    - 通过递归对段内的量进行计算：
        可以考虑 [l, r]的 mSum 对应的区间是否跨越 m——它可能不跨越 m，也就是说 [l, r] 的 mSum 可能是「左子区间」的 mSum 和 「右子区间」的 mSum 中的一个；它也可能跨越 m，可能是「左子区间」的 rSum 和 「右子区间」的 lSum 求和。三者取大。
    
    - 时空复杂度分析： 相当于遍历了整棵二叉树，时间复杂度O(n)； 由于递归过程空间复杂度为O(logn)，树的深度为logn

```class Solution {
public:
    struct Status {
        int lSum, rSum, mSum, iSum;
    };

    Status pushup(Status l, Status r){
        int iSum=l.iSum+r.iSum;
        int lSum=max(l.lSum,l.iSum+r.lSum);
        int rSum=max(r.rSum,r.iSum+l.rSum);
        int mSum=max(max(l.mSum,r.mSum),l.rSum+r.lSum);
        return (Status){lSum,rSum,mSum,iSum};
    }

    Status get(int l,int r,vector<int>& nums){
        if(l==r){
            return (Status){nums[l],nums[l],nums[l],nums[l]};
        }
        int m=(l+r)/2;
        Status lSub = get(l,m,nums);
        Status rSub = get(m+1,r,nums);
        return pushup(lSub,rSub);
    }
    int maxSubArray(vector<int>& nums) {
        //vector<int> res(nums.size());
        return get(0,nums.size()-1,nums).mSum;
        
    }
};
```



### 198. 打家劫舍
- 计算非间隔取数的最大值
- DP算法求解： dp[x]表示以第x个值结尾打劫取得的最大值：
    状态转移公式如下 dp[x]=max(dp[x-1],dp[x-2]+a[x]),dp[0]=a[0];dp[1]=max(a[0],a[1])
- 时间复杂度O(N) 空间复杂度O(n)

```class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==0){return 0;}
        
        vector<int> dp;
        dp.push_back(nums[0]);
        for(int i=1;i<nums.size();i++){
            if(i<=1){
                dp.push_back(max(nums[i],dp[i-1]));
            }
            else{
                dp.push_back(max(dp[i-1],dp[i-2]+nums[i]));
            }
        }
        return dp[nums.size()-1];

    }
};
```

- **通过滚动数组压缩空间：仅用两个变量来记录即可**，在状态更新过程中进行变量移动更新，将空间复杂度压缩至O(1)

```class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==0){return 0;}
        
        int odd=nums[0];
        int even=odd;

        for(int i=1;i<nums.size();i++){
            if(i<=1){
                even=max(odd,nums[i]);
            }
            else{
                int tmp=(max(even,odd+nums[i]));
                odd=even;
                even=tmp;
            }
        }
        return even;

    }
};
```

### 55. 跳跃游戏 [Medium]
- 可以通过贪心的思路进行处理
- 计算最大路径，**需要判断当前位置是否可达**即`i<=maxStep`

```
class Solution {
public:
    bool canJump(vector<int>& nums) {
        
        if (nums.size() <= 1)
            return true;
        int maxStep = nums[0];
        for (int i = 1; i < nums.size() - 1; i++) {
            if (i <= maxStep) {
                maxStep = max(nums[i] + i, maxStep);
            }
        }
        return maxStep >= nums.size() - 1;
        
    }
};
```
### 62. 不同路径 [Medium]
- 经典的dp任务： **给出矩形，计算到达右下角的路径数量**
  - O(MN)
  - `dp[i][j] = dp[i-1][j] + dp[i][j-1]`
```
class Solution {
public:
    int uniquePaths(int m, int n) {
        int dp [100][100];
        
        for(int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for(int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 1;i < m; i++) {
            for (int j=1; j< n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

- 更直接的思路：组合数学公式：
  - `C = C(m+n-2,m-1)` 组合公式


### 63. 不同路径 2
- 在上面的基础上，增加障碍物品, dp时跳过障碍点
- 使用滚动数组的方式来减少dp表的内存占用
- 时间复杂度 `O(mn)` 空间复杂度`O(n)`
```
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<int> dp(n);
        dp[0] = (obstacleGrid[0][0] == 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j]) {
                    dp[j] = 0;
                    continue;
                }
                if (j - 1 >=0 && obstacleGrid[i][j-1] ==0) {
                    dp[j] += dp[j-1];
                }
            }
        }
        return dp.back();
    }
};
```
### 980. 不同路径 3 [Hard]


### 322. 零钱兑换 [Medium]
- dp方法的基础，**状态转移公式**： `dp[i] = min (dp[i - r_k]) + 1`
- **初始化**： 
  - dp[0] = 0
  - 其他元素初始为`amount + 1`, 直接初始化为最大值，会在计算最小值chubug
- 时间复杂度 O(nS) 空间复杂度 O(n)
```
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        vector<int> dp(amount + 1, amount + 1);// 技巧
        dp[0] = 0;
        // for (int i = 0; i < n; i++)
        //     dp[coins[i]] = 1;
        for (int i = 1; i <= amount; i++) {
            for (auto coin : coins) {
                if(i - coin >= 0) {
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
           // dp[i] = tmp;
        }
        // for (auto s : dp) {
        //     cout << s << " ";
        // }
        // cout << endl;
        if (dp[amount] == amount + 1)
            return -1;
        return dp[amount];

    }
};
```

### 最长上升子序列
- 基础DP思路
  - 状态转移公式 `dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]`
  - 初始化：`dp[0]=0` 
  - 最后结果需要从dp中选取最大的值
  - 时间复杂度O(n^2), 空间复杂度 O(N)

```
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = 1;
        int ans = 1;
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = 1;
            for (int j = 0; j< i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            ans = max(dp[i], ans);
        } 
        // for(auto s: dp)
        //     cout << s << " ";
        // cout << endl;
        // sort(dp.begin(), dp.end());
        return ans;
    }
};
```

- **贪心+二分搜索**
  - 要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。
  - 基于上面的贪心思路，维护一个数组 d[i]，表示长度为 ii 的最长上升子序列的末尾元素的最小值，用 \textit{len}len 记录目前最长上升子序列的长度，起始时 lenlen 为 11，d[1] = \textit{nums}[0]d[1]=nums[0]


```
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> tail; // 定义不同长度的子序列的最大尾值
        int ans;
        tail.push_back(nums[0]);
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > tail.back()) {
                tail.push_back(nums[i]);
            }
            else {
                int left = 0;
                int right = tail.size() - 1;
                //cout << 'l' << left << 'r' << right << " "<< nums[i] <<endl;
                while(left < right) {
                    // int mid = left + (right - left)/2;
                    int mid = (left + right) / 2;
                    if (tail[mid] < nums[i]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
               tail[left] = nums[i];
            }
        }
        return tail.size();
    }
};
```

