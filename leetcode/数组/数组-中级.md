- [进阶](#进阶)
  - [31. 下一个排列 [Medium]](#31-下一个排列-medium)
  - [剑指offer 03. 数组中重复的数字](#剑指offer-03-数组中重复的数字)
  - [41.缺失的第一个正数](#41缺失的第一个正数)
  - [442. 数组中重复的数据](#442-数组中重复的数据)
  - [42. 接雨水 [Hard] [*]](#42-接雨水-hard-)
  - [60. 排列序列](#60-排列序列)
  - [剑指62. 圆圈最后剩下的数字](#剑指62-圆圈最后剩下的数字)
  - [73. 矩阵置零  [Medium]](#73-矩阵置零--medium)
  - [剑指offer 43. 1~n整数中1出现的次数](#剑指offer-43-1n整数中1出现的次数)
- [滑动窗口解题技巧](#滑动窗口解题技巧)
  - [剑指57-II. 和为s的连续正数序列](#剑指57-ii-和为s的连续正数序列)
  - [76. 最小覆盖子串 [Hard] * [字节/百度]](#76-最小覆盖子串-hard--字节百度)
  - [补充题：最多覆盖点问题 [百度/美团 *]](#补充题最多覆盖点问题-百度美团-)
  - [209. 长度最小的子数组](#209-长度最小的子数组)
  - [293. 滑动窗口最大值 [Hard] *](#293-滑动窗口最大值-hard-)
  - [718. 最长重复子数组](#718-最长重复子数组)
- [前缀和解题技巧](#前缀和解题技巧)
  - [560. 和为K的子数组](#560-和为k的子数组)


## 进阶


### 31. 下一个排列 [Medium]

- 算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列
> 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465

> 还希望**下一个数增加的幅度尽可能的小**，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求:

1. 在尽可能靠右的低位进行交换，需要从后向前查找
2. 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
3. 将「大数」换到前面后，**需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列**。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列

- 关键两个步骤： 低位交换 和 后序序列的翻转
  - 低位交换： 找到相邻的< 组合， 
```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int length = nums.size();
        if (length <= 1)
            return;
        int p1 = length - 2;
        int p2 = length - 1;
        int tmp = length - 1;
        // 寻找低位
        while (p1 >= 0 && nums[p1] >= nums[p1 + 1]) {
            p1--;
        }
        // 后序元素跟低位进行交换
        if (p1 >= 0) {
            // 寻找后面第一个大于 低位的元素
            while (tmp >= 0 && nums[p1] >= nums[tmp]) {
                tmp--;
            }
            swap(nums[tmp], nums[p1]);
        }
        // 翻转后面的序列
        reverse(nums.begin() + p1 + 1, nums.end());
    }
};
```
### 剑指offer 03. 数组中重复的数字

> 在一个长度为 n 的数组 nums 里的**所有数字都在 0～n-1 的范围内**。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。**请找出数组中任意一个重复的数字**

- 最基本的做法： 哈希表方法，通过哈希表检查是否为重复数字， 时间复杂度O(N) 空间复杂度O(N)
- 本题更出色的做法在于： **原地置换**
  - 由于数字范围在0 ~ n-1之间，可以把每个数字置换到`nums[i] = i`的位置，重复数字则会出现重复置换，即多对一的情况
  - 这种置换的思路在**[LC41.缺失的第一个正数]**中也有体现
  - 注意实现的时候的循环逻辑，只有当**当前索引与值一致时才向后遍历**
  - 时间复杂度 ： O(N) 空间复杂度 O(1)


![avtar](offer03.png)
```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int i = 0;
        while( i < nums.size()) {
            if (nums[i] == i) {
                i++;
                continue;
            }
            if (nums[i] == nums[nums[i]])
                return nums[i];
            
            swap(nums[i], nums[nums[i]]);
        }
        return 0;
    }
};
```

### 41.缺失的第一个正数
> 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

- 数组的正整数范围在[1, n];
- 可以将目前数组nums中在上述范围上的数字移动到对应位置： nums[i] = i + 1;
  - **细节是魔鬼** 要连续移动至 nums[i] = nums[nums[i] - 1]， 避免单次移动出现遗漏
  - 之后遍历数组返回第一个`nums[i]!= i + 1`的情况
- 时间复杂度 O(N) 空间复杂度O(1)
   
```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            // 连续移动， 避免被移动到遍历过的位置的数字存在合理
            while (nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        for (int i = 0; i < n ; i++) {
            if (nums[i] != i + 1)
                return i + 1;
        }
        cout << n <<endl;
        return n + 1;
    }
};
```
### 442. [数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)
> 给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。**找到所有出现两次的元素**。

- 题目中要求时间复杂度 O(N) 空间复杂度 O(1), 限制了我们对题目的想象
- 与[LC41缺失的第一个正数]相似，利用数组元素的值和索引值进行映射调整
  - 这类题目往往都指明：元素范围`1 ≤ a[i] ≤ n`， 能够保证元素重新映射到相等索引上的正确性
  - 本题中为了检验是否重复，利用映射后的元素`nums[nums[i] - 1]`进行辅助判断
  - 当首次出现元素时`nums[nums[i] - 1]`取反， **当遇到元素负值时说明对应的nums[i]出现重复**
  - **由于元素值取反后为负数，在进行索引映射时需要取绝对值**
- 关键点： **`数组元素与索引映射`**
```c++
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            // **由于元素值取反后为负数，在进行索引映射时需要取绝对值**
            int t = abs(nums[i]);
            // 使用数据对应的索引位置上的正负号来标记当前是否重复
            if (nums[t - 1] < 0) {
                res.push_back(t);
            }
            else {
                nums[t - 1] = -nums[t - 1];
            }
        }
        return res;
    }
};
```

### 42. 接雨水 [Hard] [*]
- 当前位置的盛水量取决于左侧/右侧相对最高位置的比较情况
- 使用双指针法，每次更新左/右当前的最高位置，取最低位置计算结果
  - 本质上将，当前位置的接水量取决于当前位置左右的最高点
  - 双指针法简化了重复求每个位置左右最高点的计算过程
- 时间复杂度 O(N)
- 关键点 **`单调栈`**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int l_max = 0;
        int r_max = 0;
        int left = 0;
        int right = height.size() - 1;
        int ans = 0;
        while (left <= right) {
            l_max = max(l_max, height[left]);
            r_max = max(r_max, height[right]);
            if (r_max < l_max) {
                ans += (r_max - height[right]);
                right--;
            }
            else {
                ans += (l_max - height[left]);
                left++;
            }
        }
        return ans;
    }
};
```

### 60. 排列序列
> 给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，给定 n 和 k，返回第 k 个排列。

```c++
输入：n = 3, k = 3
输出："213"
```

- 本质上可以通过回溯法进行求解，但在剪枝上需要有很多设计，否则时间复杂度比较高
- 本题最关键的思路**在于缩小空间/问题规模**，具体通过对排序各位的数学分析来锁定最后的目标排列：
  - 首先确定排列中的首个元素$a_1$, 以1为首的排列有 $(n -1)!$个..
    - 因此**首数字**为： $a = \lfloor (k - 1) / (n-1)! \rfloor + 1$ 
    - 注意这个公式，它避免了很多错误的情况， 如果表示为$a = \lfloor (k ) / (n-1)! \rfloor + 1$，**在k整除的情况下就会出现结果错误**
  - 最终每个位置上的结果为： $ (k - 1) mode (n - 1)! + 1$
  - 在遍历过程中，**使用数组记录各个数字是否被使用**， 避免数字重复使用，得到唯一的排序结果
​
```c++
class Solution {
public:

    string getPermutation(int n, int k) {
        string ans;
        vector<int> factor(n + 1);
        // 阶乘
        factor[0] = 1;
        for (int i = 1; i <= n; i++) {
            factor[i] = factor[i - 1] * i;
        }
        /*
            k 需要先自减一 原因：
    不妨设分子为 k，那么得到的公式可能是这样的：
        ai =  ⌊k / (n-1)!⌋ + 1
    尝试使用以上公式计算 a1:
        （1）当 k < (n-1)! 时，a1 = ⌊k / (n-1)!⌋ + 1 = 1，正确
        （2）当 k = (n-1)! 时，a1 = ⌊k / (n-1)!⌋ + 1 = 2，错误
    而使用 ai =  ⌊(k-1) / (n-1)!⌋ + 1 却能正确处理这种情况
    即：只是简洁了数学公式的使用，如果不自减一的话，需要应对多种情况
    */
        k--; // 关键一步， 技巧性十足
        vector<int> valid(n + 1, 1);
        for (int i = 1; i <= n; i++) {
            // 计算倍数
            int order = k / factor[n - i] + 1; // 注意+1操作
            for (int j = 1; j <= n; j++) {
                order -= valid[j];
                // 把用过的数字设置为0；
                if (!order) {
                    ans.push_back(j + '0');
                    valid[j] = 0;
                    break;
                }
            }
            // 更新排列数量
            k %= factor[n - i];
        }
        return ans;
    }
};
```


### 剑指62. 圆圈最后剩下的数字
> **约瑟夫环问题**： 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

- 模拟操作： 循环链表逐一删除即可
- 数学分析 + 递归/迭代
  - `f(n,m) = y` 有n个数，下标从0到n-1，然后从index=0开始数，**每次数m个数, 结果为y**
  - 寻找 `f(n,m) = y` 与  `f(n - 1,m) = x` 的关系
  - 二者关系在于： n个数划掉一个数后得到的状态就是`f(n - 1,m)` 
  - 而n个数划掉的第一个数就是 `(m-1)%n` 由于是从0编码，所以要是m-1
  - 在划掉数的基础上接着划掉第二个数
  - 最后的结果就是`(m-1)%n`后 第f(n - 1,m) + 1个数就是结果 
    - `f(n,m)=[(m-1)%n+x+1]%n`
    - 化简后： `f(n,m) = [m + x] % n`  `x = f(n-1, m)` 构成递推公式

```
class Solution {
public:
    int lastRemaining(int n, int m) {
        int f = 0;
        for (int i = 2; i < n + 1; i++) {
            f = (m + f) % i;
        }
        return f;
    }
};
```


### 73. 矩阵置零  [Medium] 
> 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

- 简单的遍历即可，**通过标记数组来记录当前行/列是否有0**，如下时间复杂度O(mn) 空间复杂度O(N)
- 关键点： **`标记数组`**  **`原地置换`**
```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        set<int> cols;
        for (int i = 0; i < n; i++) {
            bool flag = false;
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == 0) {
                    cols.insert(j);
                    flag = true;
                }
            }
            if (flag) {
                matrix[i].assign(m, 0);
            }
        }
        for (int i = 0; i < n; i++) {
            for (auto j : cols) {
                matrix[i][j] = 0;
            }
        }
    }
};
```
- 进一步优化空间，实现常量级空间：使用矩阵第一行和第一列来标记是否有0， 进行两次矩阵遍历得到结果；
- 最后再更新第一行和第一列。
```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        bool row0 = false;
        bool col0 = false;
        for (int i = 0; i < n; i++) {
            if (matrix[i][0] == 0) {
                row0 = true;
            }
        }
        for (int i = 0; i < m; i++) {
            if (matrix[0][i] == 0) {
                col0 = true;
            }
        }

        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (!matrix[i][0] || !matrix[0][j]) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (row0) {
            for (int i = 0; i < n; i++) {
                matrix[i][0] = 0;
            }
        }
        if (col0) {
            for (int i = 0; i < m; i++) {
                matrix[0][i] = 0;
            }
        }
    }
};
```

### 剑指offer 43. 1~n整数中1出现的次数
> 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
> 输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

- 讨论**不同情况下的1出现情况**
  - 将当前数字n按照位数划分为high位 cur low位
  - 逐位进行计算; 以2304为例， cur = 0 high = 23 low = 4 digit = 10
  - 当前位cur == 0时， 出现1的次数为 high * digit 
  - cur == 1 时 , high * digit + low + 1
  - cur > 2 时， (high + 1) * digit 
  - 终止条件： high == 0 && cur == 0

```c++
class Solution {
public:
    int countDigitOne(int n) {
        long cur = n % 10;
        long digit = 1;
        long high = n / 10;
        long low = 0;
        long res = 0;
        while (cur != 0 || high != 0) {
            if (cur == 0) {
                res += high * digit;
            }
            else if (cur == 1) {
                res += high * digit + low + 1;
            }
            else {
                res += (high + 1)* digit;
            }
            low += digit * cur;
            cur = high % 10;
            high /= 10;
            digit *= 10;
        }
        return res;
    }
};
```

## 滑动窗口解题技巧

### 剑指57-II. 和为s的连续正数序列
> 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（**至少含有两个数**)。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```
- 题目描述中透露出浓浓的双指针解题/滑动窗口的味道
- 解题可以**设置左右指针，每次计算窗口内的和，与target进行大小比较**
  - 确定移动left / right指针
  - 在找到相等窗口，存储结果后，左右指针都继续向右移动
- 终止条件： **`left < right`**
- 关键点： **`双指针 滑动窗口`**

```c++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        int n = target / 2 + 1;
        int left = 1;
        int right = 2;
        int sum = 0;
        vector<vector<int>> ans;
        while (left < right) {
            int sum =  (right - left  + 1) * (left + right) / 2;
            if (sum == target) {
                vector<int> tmp;
                for (int i = left; i <= right; i++)
                {
                    tmp.push_back(i);
                }
                ans.push_back(tmp);
                left++;
                right++;
            }
            else if (sum < target) {
                right++;
            }
            else if (sum > target) {
                left++;
            }
        }
        return ans;
    }
};
```







### 76. 最小覆盖子串 [Hard] * [字节/百度]
> 一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 ""

- 两个字符串的对比和搜索，典型的滑窗题目，设置滑窗在s中搜索符合t的区间，更新滑窗的过程并更新结果
  1. 使用哈希表存储当前滑窗数据和子串t的元素分布
  2. [left, right)滑窗，移动right指针，将right指针对应的元素更新到滑窗中 **当t中有该元素再更新**
  3. 当滑窗和子串need的某元素分布一致，valid++，更新当前状态
  4. 当valid==need.size 时得到满足条件的滑窗，记录结果，并进行滑窗更新 即**移动左指针**
    - 移动后，有很多细节需要注意：一个是valid的更新，一个是window数据的更新，仅当左指针的元素是need中元素时才进行上面的更新处理
- 时间复杂度 O(N)

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> need;
        for (auto c : t) {
            need[c]++;
        }
        cout << need.size() << endl;
        unordered_map<char, int> window;
        int left = 0;
        int right = 0;
        int valid = 0; // 辅助判断滑窗是否满足条件
        int min_l = INT_MAX;
        string ans;
        int start = 0;
        while (right < s.size()) {
            // s1: 构建窗口
            char c = s[right];
            right++;
            // 细节1
            if(need.count(c)) {
                window[c]++; // 加入滑窗
                if(window[c] == need[c]) // 某一元素满足条件
                    valid++;
            }
            //printf( "1 window: [%d, %d)\n", left, right);
            // s2 : 更新滑窗数据， 更新结果
            // 细节2
            while (valid == need.size()) {
                if (right - left < min_l) {
                    min_l = right - left;
                    start = left;
                }
                char d = s[left];
                left++;
                // 移除辅助判断条件  更新当前滑窗状态；
                // 细节3  只有当target串中有该元素才处理
                if (need.count(d)) {
                    if (window[d] == need[d]) {
                        valid--;
                    }
                    window[d]--;
                }
            }
            //printf( "2 window: [%d, %d)\n", left, right);

        }
        return min_l == INT_MAX ? "" : s.substr(start, min_l);
    }
};
```


### 补充题：最多覆盖点问题 [百度/美团 *]

> 数轴上从左到右有n个点a[0],a[1]…,a[n-1]，给定一根长度为L的绳子，求绳子最多能覆盖其中的几个点。要求算法复杂度为o(n)， 空间复杂度为O(1)

- 双指针法，滑窗进行
- 当**当前窗口长度大于最大长度时**，更新结果 `right - left`， 并移动左指针； 否则移动右指针

```
长度： 3 ； 6个数字
3 6
1 2 5 6 8 9
```

```c++
int maxPoints(vector<int>& nums, int len) {
    int ans = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        if ( (nums[right] - nums[left]) > len) {
            ans = max(ans, right - left);
            left++;
        }
        else {
            right++;
        }
        //cout << "l : " << left << " r :" << right << " " << ans << endl;
    }
    cout << ans << endl;
    return ans;
}
```


### 209. 长度最小的子数组
- 计算数组中和大于目标值的最小长度的连续子数组
- 做法一： 前缀和 + 二分搜索
  - 计算各位置的前缀和，由于前缀和数组是有序的，可以通过二分搜索的方法来查找后续是否有满足target和要求的前缀和
  - 时间复杂度 O(nlogn) 空间复杂度 O(n)
```c++
class Solution {
public:
     // 寻找 <= pre - target
    int binarySearch(int target, int left, int right, vector<int>& nums) {
        int res = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                res = mid;
                right = mid - 1;
            }
            else {
                left = mid + 1;
            }
        }
        return res;
    }
    int minSubArrayLen(int target, vector<int>& nums) {
        vector<int> sums( nums.size() + 1);
        for (int i = 0; i < nums.size(); i++) {
            sums[i + 1] = sums[i] + nums[i];
        }
        int left = 0;
        int ans = nums.size() + 1;
        for (int i = 1; i <= nums.size(); i++) {
            int bound = binarySearch(sums[i - 1] + target, left, sums.size() - 1, sums);
            if (bound == -1)
                continue;
            ans = min(ans, bound - (i - 1));
            left = bound;
        }
        return ans == nums.size() + 1 ? 0 : ans;
    }
};
```

- **更简单的滑窗做法**
  - 设置左右指针，从左到右遍历，当当前窗口内和满足条件时即记录长度，并调整左指针
    - 时间复杂度O(N) 空间复杂度 O(N)
  - 与**补充题： 最多覆盖点题目**相似

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0;
        int right = 0;
        int length = nums.size();
        int sum = 0;
        int ans = length + 1;
        while (right < length && left <= right) {
            sum += nums[right];
            // 移动左指针，更新结果
            while (sum >= target) {
                ans = min(right - left + 1, ans);
                sum -= nums[left];
                left ++;
            }
            // 移动右指针
            right++;
        }
        return ans == length + 1 ? 0 : ans;
    }
};
```


### 293. 滑动窗口最大值 [Hard] *
> 一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位，求每个窗口的最大值


- 双向队列解题
  - deque<int>window，用于存储下标。这个变量有以下特点:
  - 变量的最前端（也就是 window.front()）是**此次遍历的最大值的下标**
  - **当我们遇到新的数时，将新的数和双项队列的末尾（也就是window.back()）比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才停止**，做法有点像使用栈进行括号匹配。
  - 双项队列中的所有值都要在窗口范围内
- 关键逻辑： **元素入队操作和队列合法判断**
- 时间复杂度 O(N) 空间复杂度O(k)
```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        // 双向队列解题 维护队首值最大
        if (nums.empty() || k == 0)
            return nums;
        deque<int> window;
        vector<int> ans;
        for (int i = 0; i < k; i++) {
            while(!window.empty() && nums[i] > nums[window.back()]) {
                window.pop_back();
            }
            window.push_back(i);
        } 
        ans.push_back(nums[window.front()]);
        for (int i = k; i < nums.size(); i++) {
            // 如果已经超出当前窗口 将队首进行出栈
            if (!window.empty() && i - k >= window.front()) {
                window.pop_front();
            }
            while (!window.empty() && nums[i] > nums[window.back()]) {
                window.pop_back();
            }
            window.push_back(i);
            ans.push_back(nums[window.front()]);
        }
        return ans;

    }
};
```

### 718. 最长重复子数组
> 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

- 滑窗方法解题，**分别移动A/B，调整两个数组的对齐位置，然后进行同位置元素对比，记录连续重复元素的个数**
  - 时间复杂度 O(N+M)*min(n,m) 
  - 空间复杂度 O(1)

```c++
class Solution {
public:
    int findRepeat(vector<int> A, vector<int> B, int addA, int addB, int len) {
        int res = 0;
        int k = 0;
        // 记录当前遍历下的最优结果
        for (int i = 0; i < len; i++) {
            if (A[addA + i] == B[addB + i])
                k++;
            else {
                k = 0;
            }
            res = max(res, k);
        }
        return res; 

    }
    int findLength(vector<int>& A, vector<int>& B) {
        int m = A.size();
        int n = B.size();
        int ans = 0;
        // 左移B数组
        // 当结果大于/等于当前对齐长度后break
        for (int i = 0; i < n - 1; i++) {
            int len = min(m, n - i);
            if (ans >= len)
                break;
            ans = max(findRepeat(A, B, 0, i, len), ans);
        }
        // 左移A数组
        // 当结果大于/等于当前对齐长度后break
        for (int i = 0; i < m - 1; i++) {
            int len = min(n, m - i);
            if (ans >= len)
                break;
            ans = max(findRepeat(A, B, i, 0, len), ans);
        }
        return ans;
    }
};
```

- **动态规划**解法
  - 定义`dp[i][j]` 表示A数组以i开始和B数组以j开始的子串的最大公共长度；
  - dp[i][j] = dp[i+1][j+1] + 1 if dp[i] == dp[j]; otherwise dp[i][j] = 0;
  - 最终结果为dp数组中的最大值
- 时间复杂度 `O(M*N)` 空间复杂度 `O(M*N)`
```
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int m = A.size();
        int n = B.size();
        int ans = 0;
        // 多增加一维，便于初始化
        vector<vector<int>> dp(m + 1, vector<int> (n + 1));
        //反向遍历 更新dp数组
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (A[i] == B[j]) {
                    dp[i][j] = dp[i + 1][j + 1] + 1;
                }
                else {
                    dp[i][j] = 0;
                }
                ans = max(ans, dp[i][j]);
            }
        }
        return ans;
    }
};
```

## 前缀和解题技巧

### 560. 和为K的子数组

> 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

```
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况
```

- 题目分析： 看起来像是滑动窗口能做的题目，但实际上这个地方计算的是连续子数组，数组也不一定有序，无法使用双指针+滑动窗口
- **连续子数组的和**提醒我们可以使用前缀和的方式来快速求解
- 之前在[LC437.二叉树路径总和3]中就体验了前缀和的便捷。
- 利用前缀和的关键： 寻找`sum-k`对应的前缀和出现的次数就得到了对应目标值的组合情况
  - 初始化： 需要将前缀和字典先初始化 `(0, 1)`, 以应对sum -target = 0 的特殊情况
- 时间复杂度 O(N)  空间复杂度 O(N)
- 关键点： **`前缀和 + 哈希表`**

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> prefix;
        int sum = 0;
        int ans = 0;
        prefix[0] = 1; // 初始化
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            if (prefix.count(sum - k)) {
                ans += prefix[sum - k];
            }
            prefix[sum]++;
        }
        return ans;
    }
};
```

- 更多相同类型题目分析：https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/