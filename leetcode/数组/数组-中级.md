- [进阶](#进阶)
  - [31. 下一个排列 [Medium]](#31-下一个排列-medium)
  - [556. 下一个更大元素 III](#556-下一个更大元素-iii)
  - [670. 最大交换](#670-最大交换)
  - [剑指offer 03. 数组中重复的数字](#剑指offer-03-数组中重复的数字)
  - [41.缺失的第一个正数](#41缺失的第一个正数)
  - [442. 数组中重复的数据](#442-数组中重复的数据)
  - [42. 接雨水 [Hard] [*]](#42-接雨水-hard-)
  - [60. 排列序列](#60-排列序列)
  - [剑指62. 圆圈最后剩下的数字](#剑指62-圆圈最后剩下的数字)
  - [73. 矩阵置零  [Medium]](#73-矩阵置零--medium)
  - [剑指offer 43. 1~n整数中1出现的次数](#剑指offer-43-1n整数中1出现的次数)
  - [134. 加油站](#134-加油站)
  - [135. 分发糖果 **](#135-分发糖果-)
- [滑动窗口解题技巧](#滑动窗口解题技巧)
  - [剑指57-II. 和为s的连续正数序列](#剑指57-ii-和为s的连续正数序列)
  - [76. 最小覆盖子串 [Hard] * [字节/百度]](#76-最小覆盖子串-hard--字节百度)
  - [补充题：最多覆盖点问题 [百度/美团 *]](#补充题最多覆盖点问题-百度美团-)
  - [209. 长度最小的子数组](#209-长度最小的子数组)
  - [862. 和至少为 K 的最短子数组 [Hard]](#862-和至少为-k-的最短子数组-hard)
  - [293. 滑动窗口最大值 [Hard] *](#293-滑动窗口最大值-hard-)
  - [718. 最长重复子数组](#718-最长重复子数组)
- [前缀和解题技巧](#前缀和解题技巧)
  - [525. 连续数组](#525-连续数组)
  - [560. 和为K的子数组](#560-和为k的子数组)


## 进阶


### 31. 下一个排列 [Medium]

- 算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列
> 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465

> 还希望**下一个数增加的幅度尽可能的小**，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求:

1. 在尽可能靠右的低位进行交换，需要从后向前查找
2. 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
3. 将「大数」换到前面后，**需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列**。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列

- 关键两个步骤： 低位交换 和 后序序列的翻转
  - 低位交换： 找到相邻的< 组合， 
```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int length = nums.size();
        if (length <= 1)
            return;
        int p1 = length - 2;
        int p2 = length - 1;
        int tmp = length - 1;
        // 寻找低位
        while (p1 >= 0 && nums[p1] >= nums[p1 + 1]) {
            p1--;
        }
        // 后序元素跟低位进行交换
        if (p1 >= 0) {
            // 寻找后面第一个大于 低位的元素
            while (tmp >= 0 && nums[p1] >= nums[tmp]) {
                tmp--;
            }
            swap(nums[tmp], nums[p1]);
        }
        // 翻转后面的序列
        reverse(nums.begin() + p1 + 1, nums.end());
    }
};
```

### 556. 下一个更大元素 III 
> 正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。
> 返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1

- 与[LC31.下一个排列]做法一致，区别在于此处输入为32位正数，翻转计算后**可能存在溢出**
  - s1. 正整数转 string
  - s2. 寻找低位 [left < left + 1]； 若不存在低位，说明木的结果
  - s3. 存在低位： 则进行从个位开始搜索大于低位数字的首个值， 然后进行交换
  - s4. 为了保证是下一个紧邻的元素，**将低位后面的数字进行反序** （在前面的搜索过程中已经确保了这些部分是降序的，反序后的得到的值才是正确值）
- 特殊情况处理：
  - 最后需要添加对**溢出情况的处理**
- 时间复杂度 O(N) 空间复杂度 O(N)

```c++
class Solution {
public:
    int nextGreaterElement(int n) {
        string s = to_string(n);
        if (s.size() <= 1) return -1;
        int p2 = s.size() - 2;
        // 寻找左  < left
        while (p2 >= 0 && s[p2 + 1] <= s[p2]) {
            p2--;
        }
        if (p2 < 0) {
            return -1;
        }
        int t = s.size() - 1;
        // 翻转后序的部分：
        while (t >= 0 && s[t] <= s[p2]) {
            t--;
        }
        swap(s[p2], s[t]);
        reverse(s.begin() + p2 + 1, s.end());
        long val = stol(s);
        if (val > INT_MAX || val <= n) return -1;
        return val;
    }
};
```

### 670. 最大交换
> 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。

```
输入: 2736
输出: 7236
解释: 交换数字2和数字7。
```
- 与[LC37.下一个排列]有相似之处，但细节上差异还挺大
- 本题也是要找到**高位上的最小值和低位上的最大值**，进行交换，但是需要注意的是计算过程是相对的
  - 在实现上通过辅助数组巧妙地完成这一寻找：
  - s1. 从低位到高位进行遍历， 确定**每个位置上从低到高的最大取值** （用辅助数组进行记录）
  - s2. 从高向低遍历，判断当前位置是否可以进行交换得到最大取值(通过上一步的辅助数组进行判断)； 若出现这种情况，直接进行交换即可得到结果

> 核心思想：**把尽可能低位的最大数字与尽可能高位的小数字交换**
1. 先从低位往高位遍历，保存每一位经过交换能得到的最大值的下标
2. 再从高位往低位遍历，直到某一位小于该位可以取到的最大值，上一步保存了该位置最大值的下标，交换即可


```c++
class Solution {
public:
    int maximumSwap(int num) {
        string s = to_string(num);
        vector<int> tmp(s.size()); //记录各个位置上的最大值
        int _m = s.size() - 1;
        for (int i = s.size() - 1; i >= 0; i--) {
            // 从低位到高位记录每个位置上的可能的最大取值
            if (s[i] > s[_m]) _m = i;
            tmp[i] = _m; 
        }
        // 然后从高位到低位进行遍历 对首个位置最大取值在低位的元素进行交换
        for (int i = 0; i < s.size(); i++) {
            if (s[tmp[i]] != s[i]) {
                swap(s[i], s[tmp[i]]);
                break;
            }
        }
        return stoi(s);
    }
};
```

### 剑指offer 03. 数组中重复的数字

> 在一个长度为 n 的数组 nums 里的**所有数字都在 0～n-1 的范围内**。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。**请找出数组中任意一个重复的数字**

- 最基本的做法： 哈希表方法，通过哈希表检查是否为重复数字， 时间复杂度O(N) 空间复杂度O(N)
- 本题更出色的做法在于： **原地置换**
  - 由于数字范围在0 ~ n-1之间，可以把每个数字置换到`nums[i] = i`的位置，重复数字则会出现重复置换，即多对一的情况
  - 这种置换的思路在**[LC41.缺失的第一个正数]**中也有体现
  - 注意实现的时候的循环逻辑，只有当**当前索引与值一致时才向后遍历**
  - 时间复杂度 ： O(N) 空间复杂度 O(1)


![avtar](offer03.png)
```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int i = 0;
        while( i < nums.size()) {
            if (nums[i] == i) {
                i++;
                continue;
            }
            if (nums[i] == nums[nums[i]])
                return nums[i];
            
            swap(nums[i], nums[nums[i]]);
        }
        return 0;
    }
};
```

### 41.缺失的第一个正数
> 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

- 数组的正整数范围在[1, n];
- 可以将目前数组nums中在上述范围上的数字移动到对应位置： nums[i] = i + 1;
  - **细节是魔鬼** 要连续移动至 nums[i] = nums[nums[i] - 1]， 避免单次移动出现遗漏
  - 之后遍历数组返回第一个`nums[i]!= i + 1`的情况
- 时间复杂度 O(N) 空间复杂度O(1)
   
```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            // 连续移动， 避免被移动到遍历过的位置的数字存在合理
            while (nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        for (int i = 0; i < n ; i++) {
            if (nums[i] != i + 1)
                return i + 1;
        }
        cout << n <<endl;
        return n + 1;
    }
};
```
### 442. [数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)
> 给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。**找到所有出现两次的元素**。

- 题目中要求时间复杂度 O(N) 空间复杂度 O(1), 限制了我们对题目的想象
- 与[LC41缺失的第一个正数]相似，利用数组元素的值和索引值进行映射调整
  - 这类题目往往都指明：元素范围`1 ≤ a[i] ≤ n`， 能够保证元素重新映射到相等索引上的正确性
  - 本题中为了检验是否重复，利用映射后的元素`nums[nums[i] - 1]`进行辅助判断
  - 当首次出现元素时`nums[nums[i] - 1]`取反， **当遇到元素负值时说明对应的nums[i]出现重复**
  - **由于元素值取反后为负数，在进行索引映射时需要取绝对值**
- 关键点： **`数组元素与索引映射`**
```c++
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            // **由于元素值取反后为负数，在进行索引映射时需要取绝对值**
            int t = abs(nums[i]);
            // 使用数据对应的索引位置上的正负号来标记当前是否重复
            if (nums[t - 1] < 0) {
                res.push_back(t);
            }
            else {
                nums[t - 1] = -nums[t - 1];
            }
        }
        return res;
    }
};
```

### 42. 接雨水 [Hard] [*]
- 当前位置的盛水量取决于左侧/右侧相对最高位置的比较情况
- 使用双指针法，每次更新左/右当前的最高位置，取最低位置计算结果
  - 本质上将，当前位置的接水量取决于当前位置左右的最高点
  - 双指针法简化了重复求每个位置左右最高点的计算过程
- 时间复杂度 O(N)
- 关键点 **`单调栈`**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int l_max = 0;
        int r_max = 0;
        int left = 0;
        int right = height.size() - 1;
        int ans = 0;
        while (left <= right) {
            l_max = max(l_max, height[left]);
            r_max = max(r_max, height[right]);
            if (r_max < l_max) {
                ans += (r_max - height[right]);
                right--;
            }
            else {
                ans += (l_max - height[left]);
                left++;
            }
        }
        return ans;
    }
};
```

### 60. 排列序列
> 给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，给定 n 和 k，返回第 k 个排列。

```c++
输入：n = 3, k = 3
输出："213"
```

- 本质上可以通过回溯法进行求解，但在剪枝上需要有很多设计，否则时间复杂度比较高
- 本题最关键的思路**在于缩小空间/问题规模**，具体通过对排序各位的数学分析来锁定最后的目标排列：
  - 首先确定排列中的首个元素$a_1$, 以1为首的排列有 $(n -1)!$个..
    - 因此**首数字**为： $a = \lfloor (k - 1) / (n-1)! \rfloor + 1$ 
    - 注意这个公式，它避免了很多错误的情况， 如果表示为$a = \lfloor (k ) / (n-1)! \rfloor + 1$，**在k整除的情况下就会出现结果错误**
  - 最终每个位置上的结果为： $ (k - 1) mode (n - 1)! + 1$
  - 在遍历过程中，**使用数组记录各个数字是否被使用**， 避免数字重复使用，得到唯一的排序结果
​
```c++
class Solution {
public:

    string getPermutation(int n, int k) {
        string ans;
        vector<int> factor(n + 1);
        // 阶乘
        factor[0] = 1;
        for (int i = 1; i <= n; i++) {
            factor[i] = factor[i - 1] * i;
        }
        /*
            k 需要先自减一 原因：
    不妨设分子为 k，那么得到的公式可能是这样的：
        ai =  ⌊k / (n-1)!⌋ + 1
    尝试使用以上公式计算 a1:
        （1）当 k < (n-1)! 时，a1 = ⌊k / (n-1)!⌋ + 1 = 1，正确
        （2）当 k = (n-1)! 时，a1 = ⌊k / (n-1)!⌋ + 1 = 2，错误
    而使用 ai =  ⌊(k-1) / (n-1)!⌋ + 1 却能正确处理这种情况
    即：只是简洁了数学公式的使用，如果不自减一的话，需要应对多种情况
    */
        k--; // 关键一步， 技巧性十足
        vector<int> valid(n + 1, 1);
        for (int i = 1; i <= n; i++) {
            // 计算倍数
            int order = k / factor[n - i] + 1; // 注意+1操作
            for (int j = 1; j <= n; j++) {
                order -= valid[j];
                // 把用过的数字设置为0；
                if (!order) {
                    ans.push_back(j + '0');
                    valid[j] = 0;
                    break;
                }
            }
            // 更新排列数量
            k %= factor[n - i];
        }
        return ans;
    }
};
```


### 剑指62. 圆圈最后剩下的数字
> **约瑟夫环问题**： 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

- 模拟操作： 循环链表逐一删除即可
- 数学分析 + 递归/迭代
  - `f(n,m) = y` 有n个数，下标从0到n-1，然后从index=0开始数，**每次数m个数, 结果为y**
  - 寻找 `f(n,m) = y` 与  `f(n - 1,m) = x` 的关系
  - 二者关系在于： n个数划掉一个数后得到的状态就是`f(n - 1,m)` 
  - 而n个数划掉的第一个数就是 `(m-1)%n` 由于是从0编码，所以要是m-1
  - 在划掉数的基础上接着划掉第二个数
  - 最后的结果就是`(m-1)%n`后 第f(n - 1,m) + 1个数就是结果 
    - `f(n,m)=[(m-1)%n+x+1]%n`
    - 化简后： `f(n,m) = [m + x] % n`  `x = f(n-1, m)` 构成递推公式

```
class Solution {
public:
    int lastRemaining(int n, int m) {
        int f = 0;
        for (int i = 2; i < n + 1; i++) {
            f = (m + f) % i;
        }
        return f;
    }
};
```


### 73. 矩阵置零  [Medium] 
> 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

- 简单的遍历即可，**通过标记数组来记录当前行/列是否有0**，如下时间复杂度O(mn) 空间复杂度O(N)
- 关键点： **`标记数组`**  **`原地置换`**
```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        set<int> cols;
        for (int i = 0; i < n; i++) {
            bool flag = false;
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == 0) {
                    cols.insert(j);
                    flag = true;
                }
            }
            if (flag) {
                matrix[i].assign(m, 0);
            }
        }
        for (int i = 0; i < n; i++) {
            for (auto j : cols) {
                matrix[i][j] = 0;
            }
        }
    }
};
```
- 进一步优化空间，实现常量级空间：使用矩阵第一行和第一列来标记是否有0， 进行两次矩阵遍历得到结果；
- 最后再更新第一行和第一列。
```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        bool row0 = false;
        bool col0 = false;
        for (int i = 0; i < n; i++) {
            if (matrix[i][0] == 0) {
                row0 = true;
            }
        }
        for (int i = 0; i < m; i++) {
            if (matrix[0][i] == 0) {
                col0 = true;
            }
        }

        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (!matrix[i][0] || !matrix[0][j]) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (row0) {
            for (int i = 0; i < n; i++) {
                matrix[i][0] = 0;
            }
        }
        if (col0) {
            for (int i = 0; i < m; i++) {
                matrix[0][i] = 0;
            }
        }
    }
};
```

### 剑指offer 43. 1~n整数中1出现的次数
> 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
> 输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

- 讨论**不同情况下的1出现情况**
  - 将当前数字n按照位数划分为high位 cur low位
  - 逐位进行计算; 以2304为例， cur = 0 high = 23 low = 4 digit = 10
  - 当前位cur == 0时， 出现1的次数为 high * digit 
  - cur == 1 时 , high * digit + low + 1
  - cur > 2 时， (high + 1) * digit 
  - 终止条件： high == 0 && cur == 0

```c++
class Solution {
public:
    int countDigitOne(int n) {
        long cur = n % 10;
        long digit = 1;
        long high = n / 10;
        long low = 0;
        long res = 0;
        while (cur != 0 || high != 0) {
            if (cur == 0) {
                res += high * digit;
            }
            else if (cur == 1) {
                res += high * digit + low + 1;
            }
            else {
                res += (high + 1)* digit;
            }
            low += digit * cur;
            cur = high % 10;
            high /= 10;
            digit *= 10;
        }
        return res;
    }
};
```
### 134. 加油站
> 一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1

```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]
输出: 3
```
- 通过下图的折线来表示， **黑色折线图即总油量剩余值**，若要满足题目的要求：跑完全程再回到起点，**总油量剩余值的任意部分都需要在X轴以上**，且跑到终点时：总剩余汽油量 >= 0。

- 为了让黑色折线图任意部分都在 X 轴以上，我们**需要向上移动黑色折线图，直到所有点都在X轴或X轴以上。此时，处在X轴的点即为出发点**
  - 本质在**寻找折线的最低点**
1. 首先判断总gas能不能大于等于总cost，如果总gas不够，一切都白搭对吧（总（gas- cost）不用单独去计算，和找最低点时一起计算即可，只遍历一次）；

2. 再就是找总（gas-cost）的最低点，不管正负（当然如果最低点都是正的话那肯定能跑完了）；

3. 找到最低点后，如果有解，那么**解就是最低点的下一个点**，因为总（gas-cost）是大于等于0的，所以**前面损失的gas要从最低点下一个点开始都会拿回来**


![avatar](./134.png)

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int spare = 0;
        int minSpare = INT_MAX;
        int idx = 0;
        for (int i = 0; i < gas.size(); i++) {
            spare += (gas[i] - cost[i]);
            if (spare < minSpare) {
                minSpare = spare;
                idx = i;
            }
        }
        return spare < 0 ? -1 : (idx + 1) % gas.size();
    }
};
```

### 135. 分发糖果 **
> 有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

- 关键的三条规则：
  - `ratings[i - 1] < ratings[i]`:  `cur[i] = left[i - 1] + 1`
  - `ratings[i] > ratings[i + 1]`:  `cur[i] = right[i+1] + 1`
  - 其他情况，直接设为1即可
- 最基础的做法： 从左到右 + 从右到左进行两次遍历，选择同时满足两个条件的糖果数
- 时间复杂度O(N) 空间复杂度O(N) 需要进行中间结果的记录

- 关键点： **`两次遍历`** **`对比规则`**

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        int res = 0;
        vector<int> left(n);
        for (int i = 0; i < n; i++) {
            if (i > 0 && ratings[i] > ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
            else {
                left[i] = 1;
            }
        }
        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            if (i < n - 1 && ratings[i] > ratings[i + 1]) {
                right++;
            }
            else {
                right = 1;
            }
            res += max(right, left[i]);// 
        }
        return res;
    }
};
```
- 继续优化： 尝试一次遍历解决问题
- 关键在于如何处理右规则，即当`ratings[i] < ratings[i-1]`时如何对左侧位置进行更新？
  - 进一步分析为下降序列的情况，可以计算当前位置所在的**连续下降序列**的长度`l`，将当前位置的糖果设为1， 再对之前的位置进行补偿： 加上`l`个糖果
  - 特殊情况： 当连续上升长度和下降长度相等时，**需要把最近的递增序列的最后一个同学也并进递减序列中**： 加上`l+1`个糖果
```
【1,2,4,3,2,1】 递增序列长度为3=递减序列长度3：用dec记录下连续递减了几次，评分4后出现3，dec++变为1，给1个；
                3后出现2，dec++变为2，给2个。2后出现1，dec++变为3，本应给3个，但是因为inc=dec，所以，为了
                区分评分4和3，还要多给一个给4个，这个4个其实包含下标为3的小朋友的3个和另外多给下标为2的1个。

(递减序列长度：从出现下降元素开始算第一个）。
【1,2,3,4,3,2】 递增序列长度为4>递减序列长度2：用dec记录下连续递减了几次，评分4后出现3，dec++变为1，给1个；
                3后出现2，dec++变为2，给2个。这里不需要纠结最后一个小朋友不应该是1个吗？只要是连续下降就好。
               发完 给他们换一下就好，我们只统计数量
```

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        int res = 1;
        int pre = 1; // 当前位置糖果数
        int inc = 1; // 连续上升序列长度
        int dec = 0; // 连续下降序列长度
        for (int i = 1; i < n; i++) {
            if (ratings[i - 1] <= ratings[i]) {
                dec = 0;// 更新下降序列长度
                // 确定当前位置糖数： 相等就直接设为1
                pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1; 
                res += pre;
                inc = pre; // 更新上升序列长度
            }
            else {
                dec++;
                if (inc == dec) {
                    dec++;
                }
                res += dec;
                pre = 1; // 当前值设为1
            }
        }
        return res;
    }
};
```
## 滑动窗口解题技巧

### 剑指57-II. 和为s的连续正数序列
> 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（**至少含有两个数**)。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```
- 题目描述中透露出浓浓的双指针解题/滑动窗口的味道
- 解题可以**设置左右指针，每次计算窗口内的和，与target进行大小比较**
  - 确定移动left / right指针
  - 在找到相等窗口，存储结果后，左右指针都继续向右移动
- 终止条件： **`left < right`**
- 关键点： **`双指针 滑动窗口`**

```c++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        int n = target / 2 + 1;
        int left = 1;
        int right = 2;
        int sum = 0;
        vector<vector<int>> ans;
        while (left < right) {
            int sum =  (right - left  + 1) * (left + right) / 2;
            if (sum == target) {
                vector<int> tmp;
                for (int i = left; i <= right; i++)
                {
                    tmp.push_back(i);
                }
                ans.push_back(tmp);
                left++;
                right++;
            }
            else if (sum < target) {
                right++;
            }
            else if (sum > target) {
                left++;
            }
        }
        return ans;
    }
};
```







### 76. 最小覆盖子串 [Hard] * [字节/百度]
> 一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 ""

- 两个字符串的对比和搜索，典型的滑窗题目，设置滑窗在s中搜索符合t的区间，更新滑窗的过程并更新结果
  1. 使用哈希表存储当前滑窗数据和子串t的元素分布
  2. [left, right)滑窗，移动right指针，将right指针对应的元素更新到滑窗中 **当t中有该元素再更新**
  3. 当滑窗和子串need的某元素分布一致，valid++，更新当前状态
  4. 当valid==need.size 时得到满足条件的滑窗，记录结果，并进行滑窗更新 即**移动左指针**
    - 移动后，有很多细节需要注意：一个是valid的更新，一个是window数据的更新，仅当左指针的元素是need中元素时才进行上面的更新处理
- 时间复杂度 O(N)

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> need;
        for (auto c : t) {
            need[c]++;
        }
        cout << need.size() << endl;
        unordered_map<char, int> window;
        int left = 0;
        int right = 0;
        int valid = 0; // 辅助判断滑窗是否满足条件
        int min_l = INT_MAX;
        string ans;
        int start = 0;
        while (right < s.size()) {
            // s1: 构建窗口
            char c = s[right];
            right++;
            // 细节1
            if(need.count(c)) {
                window[c]++; // 加入滑窗
                if(window[c] == need[c]) // 某一元素满足条件
                    valid++;
            }
            //printf( "1 window: [%d, %d)\n", left, right);
            // s2 : 更新滑窗数据， 更新结果
            // 细节2
            while (valid == need.size()) {
                if (right - left < min_l) {
                    min_l = right - left;
                    start = left;
                }
                char d = s[left];
                left++;
                // 移除辅助判断条件  更新当前滑窗状态；
                // 细节3  只有当target串中有该元素才处理
                if (need.count(d)) {
                    if (window[d] == need[d]) {
                        valid--;
                    }
                    window[d]--;
                }
            }
            //printf( "2 window: [%d, %d)\n", left, right);

        }
        return min_l == INT_MAX ? "" : s.substr(start, min_l);
    }
};
```


### 补充题：最多覆盖点问题 [百度/美团 *]

> 数轴上从左到右有n个点a[0],a[1]…,a[n-1]，给定一根长度为L的绳子，求绳子最多能覆盖其中的几个点。要求算法复杂度为o(n)， 空间复杂度为O(1)

- 双指针法，滑窗进行
- 当**当前窗口长度大于最大长度时**，更新结果 `right - left`， 并移动左指针； 否则移动右指针

```
长度： 3 ； 6个数字
3 6
1 2 5 6 8 9
```

```c++
int maxPoints(vector<int>& nums, int len) {
    int ans = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        if ( (nums[right] - nums[left]) > len) {
            ans = max(ans, right - left);
            left++;
        }
        else {
            right++;
        }
        //cout << "l : " << left << " r :" << right << " " << ans << endl;
    }
    cout << ans << endl;
    return ans;
}
```


### 209. 长度最小的子数组
- 计算**数组中和大于目标值的最小长度的连续子数组**
  - **全为正整数**
- 做法一： 前缀和 + 二分搜索
  - 计算各位置的前缀和，由于前缀和数组是有序的，可以通过二分搜索的方法来查找后续是否有满足target和要求的前缀和
  - 时间复杂度 O(nlogn) 空间复杂度 O(n)
```c++
class Solution {
public:
     // 寻找 <= pre - target
    int binarySearch(int target, int left, int right, vector<int>& nums) {
        int res = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                res = mid;
                right = mid - 1;
            }
            else {
                left = mid + 1;
            }
        }
        return res;
    }
    int minSubArrayLen(int target, vector<int>& nums) {
        vector<int> sums( nums.size() + 1);
        for (int i = 0; i < nums.size(); i++) {
            sums[i + 1] = sums[i] + nums[i];
        }
        int left = 0;
        int ans = nums.size() + 1;
        for (int i = 1; i <= nums.size(); i++) {
            int bound = binarySearch(sums[i - 1] + target, left, sums.size() - 1, sums);
            if (bound == -1)
                continue;
            ans = min(ans, bound - (i - 1));
            left = bound;
        }
        return ans == nums.size() + 1 ? 0 : ans;
    }
};
```

- **更简单的滑窗做法**
  - 设置左右指针，从左到右遍历，当当前窗口内和满足条件时即记录长度，并调整左指针
    - 时间复杂度O(N) 空间复杂度 O(N)
  - 与**补充题： 最多覆盖点题目**相似

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0;
        int right = 0;
        int length = nums.size();
        int sum = 0;
        int ans = length + 1;
        while (right < length && left <= right) {
            sum += nums[right];
            // 移动左指针，更新结果
            while (sum >= target) {
                ans = min(right - left + 1, ans);
                sum -= nums[left];
                left ++;
            }
            // 移动右指针
            right++;
        }
        return ans == length + 1 ? 0 : ans;
    }
};
```
### 862. 和至少为 K 的最短子数组 [Hard]
> 返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。
如果没有和至少为 K 的非空子数组，返回 -1 。 数组元素包括负数

- 比LC209只差在数据范围上，问题难度直接上来了。
  - 在LC209中的滑窗方法没法使用，但通用的**前缀和+二分搜索仍然适用**

- 先构建前缀和数组， **结合之前多次前缀和的使用，需要创建[n+1]大小的数组，首元素为0**
- 对前缀和进行遍历，搜索： `presum[i] - presum[j] > k`的情况，为了降低复杂度，这里使用单调队列的思想：
  - 使用队列记录当前前缀和的索引，构建递减前缀和，每次从前缀和大的位置向后进行结果更新；
  - 当前前缀和比队列尾部的前缀和还小的话，进行队列尾部出队操作
  - 因为：目标是计算满足和的最短数组，由于负数的存在，存在当前前缀和小于之前前缀和的情况，这种情况下的子数组长度更短，因此要进行一个递减式的单调队列维护
- 时间复杂度： O(N) 空间复杂度O(N)
- 关键点： **`前缀和 + 单调序列 deque`**
```c++
class Solution {
public:
    int shortestSubarray(vector<int>& nums, int k) {
        if (nums.empty()) return -1;
        vector<int> prefix;
        int pre = 0;
        prefix.push_back(0);
        for (auto p : nums) {
            prefix.push_back(p + pre);
            pre = prefix.back();
        }
        int ans = prefix.size() + 1;
        deque<int> q; // 使用双向队列进行数据存储
        for (int i = 0; i < prefix.size(); i++) {
            while (!q.empty() && prefix[i] - prefix[q.front()] >= k) {
                ans = min(ans, i - q.front());
                q.pop_front();
            }
            while (!q.empty() && prefix[i] <= prefix[q.back()]) {
                q.pop_back();
            }
            q.push_back(i);
        }
        return ans == prefix.size() + 1 ? -1 : ans;
    }
};
```

### 293. 滑动窗口最大值 [Hard] *
> 一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位，求每个窗口的最大值


- **双向队列解题**
  - deque<int>window，用于存储下标。这个变量有以下特点:
  - 变量的最前端（也就是 window.front()）是**此次遍历的最大值的下标**
  - **当我们遇到新的数时，将新的数和双项队列的末尾（也就是window.back()）比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才停止**，做法有点像使用栈进行括号匹配。
  - 双项队列中的所有值都要在窗口范围内
- 关键逻辑： **元素入队操作和队列合法判断**  **双向队列 deque**
- 时间复杂度 O(N) 空间复杂度O(k)
```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        // 双向队列解题 维护队首值最大
        if (nums.empty() || k == 0)
            return nums;
        deque<int> window;
        vector<int> ans;
        for (int i = 0; i < k; i++) {
            while(!window.empty() && nums[i] > nums[window.back()]) {
                window.pop_back();
            }
            window.push_back(i);
        } 
        ans.push_back(nums[window.front()]);
        for (int i = k; i < nums.size(); i++) {
            // 如果已经超出当前窗口 将队首进行出栈
            if (!window.empty() && i - k >= window.front()) {
                window.pop_front();
            }
            while (!window.empty() && nums[i] > nums[window.back()]) {
                window.pop_back();
            }
            window.push_back(i);
            ans.push_back(nums[window.front()]);
        }
        return ans;

    }
};
```

### 718. 最长重复子数组
> 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

- 滑窗方法解题，**分别移动A/B，调整两个数组的对齐位置，然后进行同位置元素对比，记录连续重复元素的个数**
  - 时间复杂度 O(N+M)*min(n,m) 
  - 空间复杂度 O(1)

```c++
class Solution {
public:
    int findRepeat(vector<int> A, vector<int> B, int addA, int addB, int len) {
        int res = 0;
        int k = 0;
        // 记录当前遍历下的最优结果
        for (int i = 0; i < len; i++) {
            if (A[addA + i] == B[addB + i])
                k++;
            else {
                k = 0;
            }
            res = max(res, k);
        }
        return res; 

    }
    int findLength(vector<int>& A, vector<int>& B) {
        int m = A.size();
        int n = B.size();
        int ans = 0;
        // 左移B数组
        // 当结果大于/等于当前对齐长度后break
        for (int i = 0; i < n - 1; i++) {
            int len = min(m, n - i);
            if (ans >= len)
                break;
            ans = max(findRepeat(A, B, 0, i, len), ans);
        }
        // 左移A数组
        // 当结果大于/等于当前对齐长度后break
        for (int i = 0; i < m - 1; i++) {
            int len = min(n, m - i);
            if (ans >= len)
                break;
            ans = max(findRepeat(A, B, i, 0, len), ans);
        }
        return ans;
    }
};
```

- **动态规划**解法
  - 定义`dp[i][j]` 表示A数组以i开始和B数组以j开始的子串的最大公共长度；
  - dp[i][j] = dp[i+1][j+1] + 1 if dp[i] == dp[j]; otherwise dp[i][j] = 0;
  - 最终结果为dp数组中的最大值
- 时间复杂度 `O(M*N)` 空间复杂度 `O(M*N)`
```
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int m = A.size();
        int n = B.size();
        int ans = 0;
        // 多增加一维，便于初始化
        vector<vector<int>> dp(m + 1, vector<int> (n + 1));
        //反向遍历 更新dp数组
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (A[i] == B[j]) {
                    dp[i][j] = dp[i + 1][j + 1] + 1;
                }
                else {
                    dp[i][j] = 0;
                }
                ans = max(ans, dp[i][j]);
            }
        }
        return ans;
    }
};
```

## 前缀和解题技巧

### 525. 连续数组
> 给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）

```
输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
```
- 与补充题 01子串基本一致
- 标准的前缀和做法，需要进行一个小转换，将0转换为-1.这样前缀和就是能与**0、1数量一致等价起来**
  - 找到相等的前缀和时进行结果更新即可，
  - **初始化**： 添加0的情况
  - 其他情况： 也可以统计当前0 1的出现差值，哈希表存储差值

- 关键点： **前缀和的拓展应用**


```c++
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        unordered_map<int, int> deltas;
        int preSum = 0;
        int res = 0;
        deltas[0] = -1; //为前缀和注入灵魂 标志着初始情况
        // 避免 [0,1] 这种情况无法计算
        for (int i = 0; i < nums.size(); i++) {
            preSum += nums[i] ? 1 : -1;
            if (deltas.count(preSum)) {
                res = max(res,  i - deltas[preSum]);
            }
            else {
                deltas[preSum] = i;
            }
        }
        return res;
    }
};
```





### 560. 和为K的子数组

> 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

```
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况
```

- 题目分析： 看起来像是滑动窗口能做的题目，但实际上这个地方计算的是连续子数组，数组也不一定有序，无法使用双指针+滑动窗口
- **连续子数组的和**提醒我们可以使用前缀和的方式来快速求解
- 之前在[LC437.二叉树路径总和3]中就体验了前缀和的便捷。
- 利用前缀和的关键： 寻找`sum-k`对应的前缀和出现的次数就得到了对应目标值的组合情况
  - **初始化**： 需要将前缀和字典先初始化 `(0, 1)`, **以应对sum -target = 0 的特殊情况**
- 时间复杂度 O(N)  空间复杂度 O(N)
- 关键点： **`前缀和 + 哈希表`**

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> prefix;
        int sum = 0;
        int ans = 0;
        prefix[0] = 1; // 初始化
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            if (prefix.count(sum - k)) {
                ans += prefix[sum - k];
            }
            prefix[sum]++;
        }
        return ans;
    }
};
```

- 更多相同类型题目分析：https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/


