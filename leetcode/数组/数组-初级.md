- [遍历问题](#遍历问题)
  - [9. 回文数](#9-回文数)
  - [54. 螺旋数组](#54-螺旋数组)
  - [59. 螺旋矩阵 II](#59-螺旋矩阵-ii)
  - [66.加一](#66加一)
  - [118. 杨辉三角](#118-杨辉三角)
  - [498. 对角线遍历](#498-对角线遍历)
- [旋转问题](#旋转问题)
    - [48.旋转图像](#48旋转图像)
  - [189. 旋转数组](#189-旋转数组)
- [位运算技巧](#位运算技巧)
  - [136. 只出现一次的数字](#136-只出现一次的数字)
  - [137. 只出现过一次的数字](#137-只出现过一次的数字)
  - [191. 位1的个数](#191-位1的个数)
  - [260. 只出现过一次的数字 II](#260-只出现过一次的数字-ii)
  - [268. 缺失的数字](#268-缺失的数字)
- [双指针技巧](#双指针技巧)
  - [26. 删除有序数组中的重复项](#26-删除有序数组中的重复项)
  - [75. 颜色分类 [Medium]](#75-颜色分类-medium)
  - [剑指21. 调整数组顺序使奇数位于偶数前面](#剑指21-调整数组顺序使奇数位于偶数前面)
  - [283. 移动零](#283-移动零)
  - [15. 3Sum [Medium]](#15-3sum-medium)
  - [88. 合并两个有序数组](#88-合并两个有序数组)
  - [350. 两个数组的交集2](#350-两个数组的交集2)
- [哈希表技巧](#哈希表技巧)
  - [1. 两数之和](#1-两数之和)
  - [36. 有效的数独](#36-有效的数独)
  - [380. 常数时间插入/删除/随机取数组元素 [Medium]](#380-常数时间插入删除随机取数组元素-medium)
- [搜索问题](#搜索问题)
  - [240. 搜索二维矩阵 II [Medium]](#240-搜索二维矩阵-ii-medium)
  - [74. 搜索二维矩阵 I [Medium]](#74-搜索二维矩阵-i-medium)


## 遍历问题
- 常考察对二维数组的不同形式的遍历

### 9. 回文数
> 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false。

- 排除特殊情况： **当为负数或者个位数为0时**，即不可能是回文数
- 采用整数反转： 反转一半整数，然后对比得到的结果是否相等(偶数位) 或者 `x = tmp/10` （奇数位）

```
class Solution {
public:
    bool isPalindrome(int x) {
        // 当为负数  或者个位数为0时，即不可能是回文数
        if (x < 0 || (x % 10 == 0 && x != 0))
            return false;
        int tmp = 0;
        while ( x > tmp) {
            tmp = tmp * 10 + x % 10;
            x /= 10;
        }
        return tmp == x || x == tmp / 10;
    }
};
```


### 54. 螺旋数组
- 螺旋遍历二维数组
  - 循环终止条件：**还有剩余的元素未遍历**
  - **设置4个index 索引来进行**
```
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int row_l = 0;
        int row_r = matrix.size() - 1;
        int col_l = 0;
        int col_r = matrix[0].size() - 1;
        vector<int> ans;
        int nums = matrix.size()* matrix[0].size();
        while (nums >= 1) {
            for (int i = col_l; i <= col_r && nums; i++) {
                ans.push_back(matrix[row_l][i]);
                nums--;
            }
            row_l++;
           
            for (int i = row_l; i <= row_r && nums; i++) {
                ans.push_back(matrix[i][col_r]);
                nums--;
            }
            cout << endl;
            col_r--;
            for (int i = col_r; i >= col_l && nums; i--) {
                ans.push_back(matrix[row_r][i]);
                nums--;
                //cout << matrix[row_r][i] << " ";
            }
            row_r--;
            for (int i = row_r; i >= row_l && nums; i--) {
                ans.push_back(matrix[i][col_l]);
                nums--;
                //cout << matrix[i][col_l] << " ";
            }
            col_l++;
        }
        return ans;
    }
};
```
### 59. 螺旋矩阵 II
> 给你一个正整数n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵matrix

- n^2个数字构成正方形，**顺时针遍历**
  - 循环终止条件 **num < n*n**
  - 与54题操作一致
```
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> target(n, vector<int>(n));
        int row_l = 0;
        int row_r = n - 1;
        int col_l = 0;
        int col_r = n - 1;
        int num = 0;
        n = n * n;
        while(num < n) {
            for (int i = col_l; i <= col_r && num < n; i++) {
                target[row_l][i] = num + 1;
                num++;
            }
            row_l ++;
            for (int i = row_l; i <= row_r && num < n; i++) {
                target[i][col_r] = num + 1;
                num++;
            }
            col_r--;
            for (int i = col_r; i >= col_l && num < n; i--) {
                target[row_r][i] = num + 1;
                num++;
            }
            row_r--;
            for (int i = row_r; i >= row_l && num < n; i--) {
                target[i][col_l] = num + 1;
                num++;
            }
            col_l++;
        }
        return target;
    }
};
```

### 66.加一
https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2cv1c/

- 数组遍历+1；对于临界情况进行额外考虑，即头部需要插入新元素
    复杂度分析： 时间复杂度O(m) 插入复杂度O(1)(vector insert)
```
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        bool next=false;
        for(int i=digits.size()-1;i>=0;i--){
            digits[i]++;
            if (digits[i]==10){
                digits[i]=0;
                next=true;
            }else{
                next=false;
                break;
            }
        }
        if(next){
            digits.insert(digits.begin(),1);
        }
        return digits;
    }
};
```

### 118. 杨辉三角
> 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。


- 时间复杂度分析：O（n(n+1)/2）
- 关键点： **`临界处理`** **`遍历`**
```
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> tri(numRows);
        if(numRows<1)
          return tri;
        tri[0].push_back(1);
        for(int i=1; i<numRows;i++){
            for(int j=0;j<i+1;j++){
                if(j==0| j==i)
                {
                    tri[i].push_back(tri[i-1][0]);
                }
                else{
                    tri[i].push_back(tri[i-1][j-1]+tri[i-1][j]);
                }
            }
        }
        return tri;
    }
};
``` 

### 498. 对角线遍历 
> 给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素

- 与螺旋矩阵遍历有相似之处，都在考察对数组和矩阵的基本操作逻辑
- 对角线遍历方式： **即保持： （x+y = k） 控制x 和 y 不超过合法范围即可**

```
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
        // x + y = k.  k = [0, 2n-1]
        vector<int> ans;
        int m = mat.size();
        int n = mat[0].size(); 
        for (int k = 0; k < max(m, n) * 2 - 1; k++) {
            // 向上遍历
            if (k % 2 == 0) {
                for (int row = min(k, m - 1); row >= 0 && (k - row) < n; row--) {
                    //cout << row << k - row << endl;
                    ans.push_back(mat[row][k - row]);
                }
            }
            else {
                for (int col = min(k, n - 1); col >= 0 && (k - col) < m ; col--) {
                    //cout << k - col << col << endl;
                    ans.push_back(mat[k - col][col]);
                }
            }
        }
        return ans;
    }
};
```
## 旋转问题
#### 48.旋转图像
> 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

- 思路：
  - 先转置矩阵，
  - 然后再**进行同行翻转即可得到旋转结果** 
  - 时间复杂度O(n^2)

```
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 矩阵转置
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for (int i = 0; i < n; i++) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```

```
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n=matrix.size();
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<i;j++){
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=tmp;
            }
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n/2;j++){
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[i][n-j-1];
                matrix[i][n-j-1]=tmp;
            }
        }
        
    }
};
```
### 189. 旋转数组
> 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数
```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4
```
- 方法1： 暴力循环
- 方法2: 环形平移
- 方法3: **三次反转数组** 
```
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k%=(nums.size());
        //int tmp=0;
        ///int start=0;
        int count=0;
        for(int i=0;count<nums.size();i++)
        {
            int current=i;
            int pred=nums[current];
            while(true)
                {
                    int next=(current+k)%nums.size();
                    int tmp=nums[next];
                    nums[next]=pred;
                    pred=tmp;
                    current=next;
                    //j=(j+k)%nums.size();
                    count++;
                    if(i==current){
                        break;
                    }
                }

        }     
        }
};
```
- **反转数组**：先反转整个数组，再反转前k个数字，再反转最后的n-k个数字。
```
class Solution {
public:
    void reverse(vector<int>& nums, int start,int end){
        while(start<end){
            int tmp=nums[start];
            nums[start]=nums[end];
            nums[end]=tmp;
            start++;
            end--;
        }
    }
    void rotate(vector<int>& nums, int k) {
        k%=(nums.size());
        reverse(nums,0,nums.size()-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.size()-1)；  
        }
};
```
```
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        reverse(nums.begin(), nums.end());
        reverse(nums.begin() + k, nums.end());
        reverse(nums.begin(), nums.begin() + k);
    }
};
```

【利用额外空间进行数组记录】
```
class Solution {
public:
  
    void rotate(vector<int>& nums, int k) {
        k%=(nums.size());
        vector<int> a(nums.size());
        for(int j=0;j<nums.size();j++){
            a[(j+k)%nums.size()]=nums[j];
        }
        for(int j=0;j<nums.size();j++){
            nums[j]=a[j];
        }
   
        }
};
```

## 位运算技巧
### 136. 只出现一次的数字
> 给定一个非空整数数组，除了**某个元素只出现一次以外**，其余每个元素均出现两次。找出那个只出现了一次的元素

- 要求是线性时间、不占额外内存；

- 线性时间就可以想到利用排序，减少遍历复杂度；
- 如果没额外内存限制的话，就可以**利用哈希表或者集合**，记录键值。

```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        // unordered_map<int,int> keys;
        sort(nums.begin(),nums.end());
        bool pre=true;
        for(int j=0;j<nums.size()-1;j++){
            if(nums[j]!=nums[j+1]){
                if(pre) return nums[j];
                pre=true;
            
            }
            else{
                pre=false;

            }
        }
        return nums[nums.size()-1];

    }
};
```
另外一种方法：【**位运算**】
- **使用两元素的异或XOR操作**，整个数组的XOR操作即可得到没有重复的数字；
```
class Solution {
public:
    int singleNumber(vector<int>& nums) {

        int res=0;
        for(auto j: nums){
            res^=j;
        }
        return res;

    }
};
```
### 137. 只出现过一次的数字
- 给你一个整数数组 nums ，除某个元素仅出现一次外，**其余每个元素都恰出现三次**
```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int seen_once = 0;
        int seen_twice = 0;
        for (auto p : nums) {
            seen_once = ~seen_twice&(seen_once ^ p);
            seen_twice = ~seen_once&(seen_twice ^ p);
        }
        return seen_once;
    }
};
```

### 191. 位1的个数
>  输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）


```
class Solution {
public:
    int hammingWeight(uint32_t n) {
       int ans = 0;
       int l = 0;
       while (l < 32) {
           if(n & (1 << l))
                ans++;
           l++;
       } 
       return ans;
    }
};
```

### 260. 只出现过一次的数字 II 

> 给定一个整数数组 nums，其中**恰好有两个元素只出现一次**，**其余所有元素均出现两次**。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
- 基础做法：哈希表构建，然后直接搜索即可
- 进阶做法，在上一题的基础上，使用异或运算
  - 考虑异或操作的性质：**对于两个操作数的每一位，相同结果为 00，不同结果为 11**。那么在计算过程中，成对出现的数字的所有位会两两抵消为 00，最终得到的结果就是那个出现了一次的数字。
  - 如果我们可以把所有数字分成两组，使得：
    - 两个只出现一次的数字在不同的组中；
    - **相同的数字会被分到相同的组中**。
  - 那么对两个组分别进行异或操作，即可得到答案的两个数字
https://leetcode-cn.com/problems/single-number-iii/solution/zhi-chu-xian-yi-ci-de-shu-zi-iii-by-leet-4i8e/
    - 通过取全部数字异或后的结果x，根据x的位数进行分组，x_i = 1 表示两数不同，x_i = 0表示两数相同，得到满足以上要求的分组
    - 然后对两组内的元素进行异或，得到结果。

- 时间复杂度： O(N) 空间复杂度O(1)
```
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int x = 0;
        for (int i = 0; i < nums.size(); i++) {
            x ^= nums[i];
        }
        int l = 1; // 计算1最低位
        while( (l & x) == 0) {
            l <<= 1;
        }
        int a = 0;
        int b = 0;
        // 根据最后的异或位置进行分组
        
        for (auto s : nums) {
            if (s & l) {
                a ^= s;
            }
            else {
                b ^= s;
            }
        }
        return vector<int>({a,b});
    }
};
```
### 268. 缺失的数字
> 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

```
输入：nums = [3,0,1]
输出：2
```

- 基础思路：先对数组排序，然后遍历数组，查找空缺位置；时间复杂度：排序算法复杂度(O(nlogN))
- 为了追求线性复杂度，利用更简单的算法：利用高斯求和进行计算：
    - 时间复杂度 O(N) 空间复杂度 O(1)
    - **没有考虑数据溢出的情况**，求和可能会造成数据溢出
- 关键点： **`异或位运算`**  **`遍历`**
```class Solution {
public:
    int missingNumber(vector<int>& nums) {
        if(nums.empty())
        return 0;
        int lens = nums.size();
        int count = (lens+1)*(lens)/2;
        int res=0;
        for(auto i:nums)
            res+=i;
        return count-res;

    }
};
```

- **优化改进**：可以通过边加边减的操作来改写代码，这种写法并不能避免极限情况下的溢出，当循环中的前两个数字为最大的两个时，可能直接就溢出了
    - 注意写法，避免数组越界
```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        if(nums.empty())
        return 0;
        int res =  nums.size();
        for(int i=0;i<nums.size();i++){
            res+=i;
            res-=nums[i];
        }
        return res;

    }
};
```
- **最简单的优化，利用long型来存储**

- **位运算**操作，利用XOR异或运算来计算缺失值
    - 异或运算中 相同值异或为0，数组连续异或得到没有重复的数字。
    - `3^0^0^1^2^1^3=2` n*2+1个数字异或肯定得到一个不重复的数字，即缺失值
    - 时间复杂度O(N) 空间复杂度O(1)
```class Solution {
public:
    int missingNumber(vector<int>& nums) {
        if(nums.empty())
        return 0;
        int res =  nums.size();
        for(int i=0;i<nums.size();i++){
            res^=i;
            res^=nums[i];
        }
        return res;
    }
};
```
## 双指针技巧

### 26. 删除有序数组中的重复项
> 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度

- 使用双指针思想，left指针用于记录元素值，当出现重复值时跳过即可，left指针不移动
- **`双指针`**
```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty())
            return 0;
        int left = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i-1] == nums[i]) {
                continue;
            }
            else {
                nums[left] = nums[i];
                left++;
            }
        }
        return left;
    }
};
```

### 75. 颜色分类 [Medium]
- 三种颜色 0 1 2 ， 要实现对这些颜色的原地排序 从小到大排列


- 双指针法： **left指针控制0， right指针控制2，进行交换，只需要遍历一次即可完成排序**
  - 遇到0，与left进行交换，即往左甩
  - 遇到2，则与right进行交换，往右甩
  - `left < right`； 
    - 技巧点： 当进行right交换时，交换完成后要回退一步，保证避免遗漏对元素的处理，*可能将2又换到当前位置*
- 时间复杂度： `O(N)`

- 关键点： **双指针** **一次遍历**

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        for (int i = 0; i <= right; i++){
            if (nums[i] == 0) {
                swap(nums[i], nums[left]);
                left++;
            }
            if (nums[i] == 2) {
                swap(nums[i], nums[right]);
                right--;
                i--;// 解题关键
            }
        }
    }
};
```

### 剑指21. 调整数组顺序使奇数位于偶数前面
> 使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

- 跟LC75题思路相似，原地移动即可，设置left指针，将所有奇数向left指针位置交换即可
- 时间复杂度 O(N)
```
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int left = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] % 2 ) {
                swap(nums[left], nums[i]);
                left++;
            }
        }
        return nums;
    }
};
```

### 283. 移动零
> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
- 这并非一道排序题目, 仍然是数组双指针的应用
- 当当前值非0时，即往左甩，并移动left指针，否则正常移动right指针
- 与剑指21等题目十分相似


```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left = 0;
        int right = 0;
        while (right < nums.size()) {
            if (nums[right]) {
                swap(nums[left], nums[right]);
                left++;
            }
            right++;
        }
    }
};
```

### 15. 3Sum [Medium]
- 从无序数组中找出三个非重复元素和等于目标值
- TwoSum的升级
- 可以通过多次TwoSum查找来实现3Sum的计算
    - 为了避免重复，需要在遍历时跳过重复区域
    - 外层循环和内层循环都需要进行重复区域的跳过
- 时间复杂度 `O(N^2)` 空间复杂度 O(logN) 排序所需
```
class Solution {
public:
    vector<vector<int>> ans;
    void twoSum(vector<int>& nums, int target, int index) {
        int left = index + 1;
        int right = nums.size() - 1;
        while(left < right) {
            if (nums[left] + nums[right] == target) {
                if (left != index && right != index) {
                    ans.push_back({nums[index], nums[left], nums[right]});
                    //cout << nums[index] <<" " <<nums[left] << " "<< nums[right] << endl;
                }
                int cur = nums[left];
                while(left < nums.size() && nums[left]==cur) {
                    left++;
                }
                //cout << "move:" << left << " " << nums[left]<< endl;
                int curr = nums[right];
                while(right >= 0 && nums[right]==curr) {
                    right--;
                }
                //cout << "right:" << right << " " << nums[right]<< endl;
                continue;
                //left++;
            }
            else if(nums[left] + nums[right] < target) {
                left++;
            }
            else {
                right--;
            }
        }
    }
    vector<vector<int>> threeSum(vector<int>& nums) {
        if (nums.size() < 3) {
            return ans;
        }
        sort(nums.begin(), nums.end()); //排序
        int i = 0;
        while (i < nums.size()) {
            if (nums[i] > 0)
                break;
            twoSum(nums, -nums[i], i);
            int cur = nums[i];
            while(i < nums.size() && nums[i]==cur) {
                    i++;
            }
        }
        return ans;
    }
};
```

### 88. 合并两个有序数组
- 给定两个有序数组a,b， 其中a数组空间比较大，可以容纳a+b两个数组
- 思路1:  合并后排序
- 思路2： 使用双指针，借助额外空间存储a，双指针合并
- 思路3:  **逆向双指针，从后往前遍历**，将最大值往a的尾部填充
    - 最后将未合并的部分再添加到a中即可
```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // 
        int right = nums1.size() - 1;
        int p1 = m - 1;
        int p2 = n - 1;
        while (p1 >= 0 && p2 >= 0) {
            if (nums1[p1] > nums2[p2]) {
                nums1[right] = nums1[p1];
                right--;
                p1--;
            } else {
               nums1[right] = nums2[p2];
                right--;
                p2--; 
            }
        }
        // 处理剩余部分
        while(p2 >= 0) {
            nums1[right] = nums2[p2];
            right--;
            p2--; 
        }
    }
};
```

### 350. 两个数组的交集2
https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/

允许有重复的数字，计算两个数组所有重复的数字(数字本身就是可以重复)

所以不用考虑使用集合，可以通过哈希表/排序+双指针来完成。

- 双指针遍历排完序的两个数组：
  时间复杂度分析：排序复杂度O(mlogm+nlogn)；数组遍历O(m+n);总复杂度O(mlogm+nlogn);
  空间复杂度：记录结果的数组O(min(m,n))，使用STL.vector会到O(1)

```
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        
        int index=0,index2=0;
        int len=nums1.size();
        int len2=nums2.size();
        vector<int> res;
        while(index<len&&index2<len2){
            if(nums1[index]==nums2[index2]){
                res.push_back(nums1[index]);
                index++;
                index2++;
            }
            else if(nums1[index]<nums2[index2]){
                index++;
            }
            else if(nums1[index]>nums2[index2]){
                index2++;
            }
        }
        return res;
        }
};
```
- 使用哈希表，unordered_map,记录短表的元素值和频次；
- 将长表和哈希表进行遍历，对哈希表进行元素删减，并保存相同元素。
- 与上个方法比利用哈希表的遍历能力，优化了算法：
    - 时间复杂度： 遍历数组操作O(m+n)，哈希表搜索O(1),总体O(m+n)
    - 空间复杂度: O(min(m,n))
```
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.size()>nums2.size()){
            intersect(nums2,nums1);
        }
        vector<int> res;
        unordered_map<int,int> map;
        for(auto n:nums1) map[n]++;
        for(auto n:nums2){
            if(map.count(n)){
                res.push_back(n);
                map[n]--;
            }
            if(map[n]==0){
                map.erase(n);
            }

        }

        return res;
        }
};
```

## 哈希表技巧
### 1. 两数之和
给定数组和目标，找出数组两元素之和为target的元素索引

- 暴力搜索
- 哈希表：在数组线性遍历时，记录每个值的位置，以便于快速查找差值target-x是否存在。 
    时间复杂度：O(n)

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> keys;
        for(int i=0; i<nums.size();i++){
            auto iter=keys.find(target-nums[i]);
            if(iter!=keys.end()){
                return {iter->second,i};
            }
            keys[nums[i]]=i;

        }
       return {};

    }
};
```

### 36. 有效的数独
```
一个简单的解决方案是遍历该 9 x 9 数独 三 次，以确保：

行中没有重复的数字。
列中没有重复的数字。
3 x 3 子数独内没有重复的数字。
实际上，所有这一切都可以在一次迭代中完成。
```

- 通过哈希表一次记录行、列、宫三种情况的数据分布

```
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        unordered_map<int,unordered_map<char,int>> row_info;
        unordered_map<int,unordered_map<char,int>> col_info;
        unordered_map<int,unordered_map<char,int>> box_info;
        for(int i=0;i<9;i++){
            for(int j=0;j<9;j++){
                if(board[i][j]=='.')
                    continue;
                int box=int(i/3)*3+int(j/3);
                row_info[i][board[i][j]]++;
                col_info[j][board[i][j]]++;
                box_info[box][board[i][j]]++;
                

                if(box_info[box][board[i][j]]>1 ||row_info[i][board[i][j]]>1 || col_info[j][board[i][j]]>1)
                {
                    return false;
                }
            }
        }
        return true;
    }
};
```

### 380. 常数时间插入/删除/随机取数组元素 [Medium]
- 哈希表+动态数组实现
- 删除： 将尾部元素与当前要删除的元素进行交互，然后再删除尾部数组，实现常量级的删除操作
  
```
class RandomizedSet {
public:
    unordered_map<int, int> indexs;
    vector<int> ans;

    /** Initialize your data structure here. */
    RandomizedSet() {

    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    bool insert(int val) {
        //cout << "insert" << endl;
        if (indexs.count(val)) {
            return false;
        }
        ans.push_back(val);
        indexs[val] = ans.size() - 1;
        return true;

    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    bool remove(int val) {
        //cout << "remove" << endl;
        if (indexs.count(val)) {
           // cout << "remove2" << endl;
            
            
            int pos = indexs[val];
            indexs.erase(val);
            if (pos == ans.size() - 1){
                ans.pop_back();
                return true;
            }
            ans[pos] = ans.back();
            indexs[ans.back()] = pos;
            ans.pop_back();
            
            return true;
        }
        return false;
    }
    
    /** Get a random element from the set. */
    int getRandom() {
        //cout << "Random" << endl;
        return ans[rand() % ans.size()];
    }
};
```


## 搜索问题


### 240. 搜索二维矩阵 II [Medium]
> 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。
- 二分查找法：
  - 在对角线开始向下和向右的搜索

```
class Solution {
public:
    int rows = 0;
    int cols = 0;
    bool binarySearch(vector<vector<int>>& matrix, int target, int row) {
        //cout << "binarySearch" << endl;
        int left = row;
        int right = rows - 1;
        int col = row;
        while (left <= right) {
            //cout <<"l : " << left << " r :" << right << endl; 
            int mid = left + (right - left)/2;
            if (matrix[mid][col] == target) 
                return true;
            else if (matrix[mid][col] < target) {
                left = mid + 1;
            }
            else if (matrix[mid][col] > target) {
                right = mid - 1;
            }
        }
        int low = row;
        int high = cols - 1;
        while (low <= high) {
            //cout <<"low : " << low << " high :" << high << endl;
            int mid = low + (high - low)/2;
            if (matrix[row][mid] == target) 
                return true;
            else if (matrix[row][mid] < target) {
                low = mid + 1;
            }
            else if (matrix[row][mid] > target) {
                 high = mid - 1;
            }
        }
        return false;
    }
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        rows = matrix.size();
        cols = matrix[0].size();
        for (int i = 0; i < min(rows,cols); i ++) {
            if (binarySearch(matrix, target, i))
                return true;
        }
        return false;
    }
};
```
- **进阶做法**： 由于行和列都是有序的，可以将这个矩阵看作是一个搜索二叉树，
  - **将左下角元素作为根节点，向上都是小于根节点的元素，向右都是大于根节点的元素**
- 时间复杂度：`O(m+n)`
```
class Solution {
public:

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row = matrix.size() - 1;
        int col = 0;
        while(row >=0 && col < matrix[0].size()) {
            if (matrix[row][col] == target) 
                return true;
            else if (matrix[row][col] > target) {
                row--; // 向小的方向移动
            }
            else if (matrix[row][col] < target) {
                col++;
            }
        }
        return false;
    }
};
```

###  74. 搜索二维矩阵 I [Medium]
> 每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数
- 二分查找的利用
  - 先搜第一列，找出小于目标值的第一行，然后再在行内进行二分查找
  - 时间复杂度： `O(logm + logn)`
```
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int low = 0;
        int row = 0;
        int high = matrix.size() - 1;
        while(low <= high) {
            int mid = low + (high - low) / 2;
            if (matrix[mid][0] ==  target) 
                return true;
            else if (matrix[mid][0] < target) {
                row = mid;
                low = mid + 1;
            }
            else {
                high = mid - 1;
            }
        }
        //cout << row << endl;
        if (matrix[row][0] > target || matrix[row].back() < target) 
            return false;
        int left = 0;
        int right = matrix[row].size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (matrix[row][mid] ==  target) 
                return true;
            else if (matrix[row][mid] < target) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
        return false;
    }
};
```







