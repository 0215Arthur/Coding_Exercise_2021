

不要忘记 "双指针解法" ，它不仅适用于数组问题，而且还适用于链表问题。

另一种大大简化链接列表问题的方法是 "Dummy node" 节点技巧 ，所谓 Dummy Node 其实就是带头节点的指针



### 237. 删除链表指定节点

- 简单题目： 只给定待删的节点，不给链表的头节点，链表的基本操作
- 通过与待删节点的下个节点进行交换即可，

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        if(node->next!=NULL){
            ListNode * next=node->next;
            node->val=next->val;
            node->next=next->next;
            delete next;// 释放节点
        }

    }
};


### 19. 删除链表的倒数第N个节点
- 中等难度
- 1. 计算链表长度，先进行一次遍历，得到链表长度，然后再来一次遍历至要删除的节点位置，然后进行删除操作。 **考虑使用dummy node，简化对链表只有一个节点等临界情况的处理**
   时间复杂度为:O(L)  空间复杂度O(1)

- 2. 堆栈，遍历中将链表指针压入栈中，完成遍历后进行逐一出栈至倒数第N个节点
    时间复杂度 O(L)  空间复杂度O(L)

- 3. 一次遍历：利用双指针法仅一次遍历完成任务. 利用头first和end指针，控制二者之间的距离为n，遍历完成时即得到待删除的节点指针。 自己实现的就是双指针一次遍历的方法：

```/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode * start = head;
        ListNode * end = head;
        int distance=0;
        bool flag=false;
        
        while(start->next!=NULL){

                start=start->next;
                if(flag)  end=end->next;
                distance++;
                if(distance==n){
                   flag=true;
                }
            }
        if(!flag){
            cout<<"test"<<endl;
            head=end->next;
            delete end;
            return head;
        }
        if(end->next!=NULL){
            
            ListNode*tmp=end->next;
            end->next=tmp->next;
            //end->val=tmp->val;
            delete tmp;
        }else{
            delete end;
            return NULL;
        }
        return head;
      
    }
};

```

- **加上dummy-node之后，代码逻辑有明显的简化**
```/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode * dummy_node= new ListNode(0,head);
        ListNode * start = dummy_node;
        ListNode * end = dummy_node;

        int distance=0;
        bool flag=false;
        
        for(int i=0;i<n;i++){
            start=start->next;
        }
        while(start){
            start=start->next;
            end=end->next;
        }
        
        end->next = end->next->next;
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;       
    }
};
```