

### 二分查找基本模版：
- input: (array,target)
- return: index/-1
- 关键要素：
    - 循环终止条件：Left<=right
    - left mid right设置
    - 判断条件设置

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0;
        int right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid]>target) right=mid-1;
            else if(nums[mid]<target) left=mid+1;
        } 
        return -1;
    }
};
```


### 变形题目： X的平方根
- 计算平方根的整数部分，往往不是直接利用sqrt进行求解。
- 主要还是用二分查找: 时间复杂度O(logn)，空间复杂度为O(1)
    - 保存mid值作为ans

```
class Solution {
public:
    int mySqrt(int x) {
        int right=x/2;
        int left=0;
        int ans=0;
        if(x==1) return 1;
        while(left<=right){
            int mid=left+(right-left)/2;
            //cout<<mid<<endl;
            if((long long )mid*mid>x){
                right=mid-1;
            }
            else if((long long )mid*mid<=x){
          
                ans=mid;
                left=mid+1;
            }
            //cout<<left<<endl;
            
        }
        return ans;
    }
};
```

```class Solution {
public:
    int mySqrt(int x) {
        int right=x;
        int left=0;
        int ans=0;
        //if(x==1) return 1;
        while(left<=right){
            int mid=left+(right-left)/2;
            //cout<<mid<<endl;
            if((long long )mid*mid>x){
                right=mid-1;
            }
            else if((long long )mid*mid<=x){
          
                ans=mid;
                left=mid+1;
            }
            //cout<<left<<endl;
            
        }
        return ans;
    }
};
```

- 其他做法：牛顿迭代法
    - 对函数`y=x^2-C`进行迭代求解：
    - `x_1=1/2*(x_0+C/x_0)`

```class Solution {
public:
    int mySqrt(int x) {
        if(x==0) return 0;
        double C=x;
        double x0=x;
        while(true){
            double x1=0.5*(x0+C/x0);
            if(fabs(x0-x1)<1e-7){
                break;
            }
            x0=x1;
        }
        return int(x0);
    }
};
```

### 374. 猜数字大小
- 典型的二分查找应用
```/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */ 

class Solution {
public:
    int guessNumber(int n) {
        int left=1;
        int right=n;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(guess(mid)==0) return mid;
            else if(guess(mid)<0) right=mid-1;
            else if(guess(mid)>0) left=mid+1;
        }
        return -1;
    }
};
```

### 33. 搜索旋转排序数组
- 中等题目
- 给定的数组经过旋转后，是部分有序的。
- 查找中的区间定位要发生改变，要考虑部分有序的区间来搜索：
```class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        
        int right =  nums.size()-1;
        
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target)
                return mid;
            // 左侧有序
            if(nums[0]<=nums[mid]){
                if(nums[0]<=target && target<nums[mid])
                    {right=mid-1;}
                else
                    {left=mid+1;}
            }else {
                // 右侧有序
                if(nums[nums.size()-1]>=target && nums[mid]<target)
                    {left=mid+1;}
                else    
                    {right=mid-1;}
            }
          
        }
        return -1;

    }
};
```

### 在排序数组中查找元素的第一个和最后一个位置
- 二分查找寻找边界
- 分别寻找左右边界，重新定义一个函数来辅助实现
- 时间复杂度 O(logN) 空间复杂度 O(1)
```class Solution {
public:
    int binarySearch(vector<int>& nums, int target, bool left_flag){
        int left = 0;
        int right = nums.size()-1;
        while(left<=right){
            int mid = left + (right-left)/2;
            if (nums[mid]==target){
                if(left_flag){
                    right=mid-1;
                }
                else{
                    left=mid+1;
                }
            }
            else if (nums[mid]>target){
                right=mid-1;
            }
            else if (nums[mid]<target){
                left = mid+1;
            }
        }
        if(left_flag)
            return left;
        else
            return right;

    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int left_range=binarySearch(nums,target,true);
        if(left_range>=nums.size()|| nums[left_range]!=target)
            return vector<int>{-1, -1};
        int right_range=binarySearch(nums,target,false);
        return vector<int>{left_range, right_range};
    }
};
```

### 658. Find K Closest Elements 
- 中等题目
- 二分查找找边界的变形应用
- 给定有序数组，找出其中与目标`x`最接近的`K`个元素
- 思路：
    - 先用二分查找找到x的左边界：即首个`x>=`的值的index
    - 然后进行区间搜索，搜索出最优的K个近邻元素，即子区间
        - 搜索方法： **双指针法**： `low`  `high`
        - 当`low<0`或者`high`与target的距离更近时，high++
        - 当`high>=arr.size`或者`low`与target的距离更近时，low--
        - 以上调整的核心目的是避免溢出，并找到closest的区间

    - 时间复杂度： O(logN+k) 空间复杂度 O(k)

```
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        int left = 0;
        int right = arr.size()-1;
        if (arr[left]>=x){
            //vector<int> ans (arr.begin(), arr.begin()+k);
            vector<int> ans (arr.begin(), arr.begin() + k);
            return ans;
        }
        if (arr[right]<=x){
            vector<int> ans (arr.begin()+right-k+1, arr.begin()+right+1);
            return ans;
        }
        while(left<=right){
            int mid = left + (right-left)/2;
            if (arr[mid]==x)
                right=mid-1;
            else if(arr[mid]<x)
                left = mid +1;
            else 
                right = mid-1;
        }
        //cout<<"idx:"<<left<<endl;
        int start = left;
        int end  =  left;
        while(end-start-1<k){
            if(start<0){
                end++;
                continue;
            }
            if(end>=arr.size())
            {
                start--;
                continue;
            }
            if(abs(x-arr[start])<=abs(arr[end]-x)){
                start--;
            }
            else
                end++;
        }
    vector<int> ans(arr.begin()+start+1, arr.begin()+end);
    return ans;
    }
};
```
最终返回的是【start+1，end]，主要看循环条件的设置： **end-(start+1)<k**

- **二分查找的进阶优化**： 
    - 直接通过二分查找找到最优区间的左边界，当target位于区间内时通过收缩左边界来寻找最优结果
    - 二分查找的模板改造：
        1. right改为 `len-1-k`
        2. 当target位于[mid,mid+k]区间且左边间隔大时，收缩左边界
        3. 否则收缩右边界
        4. 最后返回 **[left,left+k)**

```class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        int left = 0;
        int right = arr.size()-1-k;
        if (arr[left]>=x){
            //vector<int> ans (arr.begin(), arr.begin()+k);
            vector<int> ans (arr.begin(), arr.begin() + k);
            return ans;
        }
        if (arr[arr.size()-1]<=x){
            vector<int> ans (arr.begin()+arr.size()-k, arr.end());
            return ans;
        }
        while(left<=right){
            int mid=left+(right-left)/2;
            if(x-arr[mid] > arr[mid+k]-x){
                left=mid+1;
            }
            else
                right=mid-1;   
            // cout<<'m'<<mid<<endl;
            // cout<<'l'<<left<<endl;
            // cout<<'r'<<right<<endl;
        }

    vector<int> ans(arr.begin()+left, arr.begin()+left+k);
    return ans;
    }
};
```


- 其他思路：**排除法**
    - 利用双指针，从左到右逐一删除至k个元素
    - 时间复杂度： O(n) 线性复杂度; 空间复杂度 O(k)


```
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        int left = 0;
        int right = arr.size()-1;
        if (arr[left]>=x){
            //vector<int> ans (arr.begin(), arr.begin()+k);
            vector<int> ans (arr.begin(), arr.begin() + k);
            return ans;
        }
        if (arr[right]<=x){
            vector<int> ans (arr.begin()+right-k+1, arr.begin()+right+1);
            return ans;
        }
        while(right-left+1>k){
            if(abs(x-arr[left])<=abs(arr[right]-x)){
                right--;
            }
            else
                left++;
        }
    vector<int> ans(arr.begin()+left, arr.begin()+left+k);
    return ans;
    }
};
```

### 162. 寻找峰值
- 序列中重要的前提：   `nums[i] != nums[i + 1]`
- **二分查找方法：**
    - 通过二分方法搜小搜索空间
    - 时间复杂度： O(logN)
    - 比较麻烦的是：
        - 临界点的设置： **left < right**；
        - 搜索空间的方向

```
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0;
        int right = nums.size()-1;

        while(left<right){
            int mid = left+(right-left)/2;
            if(nums[mid]>=nums[mid+1]){
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return right;
    }
};
```

- **线性搜索**
    - 在相邻元素不相等的前提下，可以得到当`nums[i]>nums[i+1]`就一定可以找到peak
    - 时间复杂度： O(N)

```
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        for(int i=0;i<nums.size()-1;i++){
            if(nums[i]>nums[i+1]){
                return i;
            }
        }
        return nums.size()-1;
    }
};
```

## 衍生题目
### 50. Pow(x,n)
- 实现幂计算
- 基本思路： 直接线性循环，暴力解法可能超时
- 基于迭代思路： `x->x^2->x^4->...`
- 时间复杂度： O(logN) 空间复杂度：（递归栈占用）O(logN)
```
class Solution {
public:
    double cal(double x, int n){
        if (n==0)
            return 1.0;
        double res = cal(x,n/2);
        return n%2==0 ? res*res: res*res*x;
    }
    double myPow(double x, int n) {
        return n>=0?cal(x,n):1.0/cal(x,-n);
    }
};
```

- **迭代写法** 
- 时间复杂度同样为 O(logN) 空间复杂度为常量级别 O(1)

```class Solution {
public:
    double cal(double x, long long n){
        double ans = 1.0;
        double tmp = x;
        while(n>0){
            if(n%2==1){
                ans*=tmp;
            }
            tmp*=tmp;
            n/=2;
        }
        return ans;
    }
    double myPow(double x, int n) {
        long long N=n;
        return N>=0?cal(x,N):1.0/cal(x,-N);
    }
};
```

### 367. 有效的完全平方数
- 使用二分查找的基础模板完成
- 考虑临界情况的处理：
    - 平方溢出情况
    - 1/0的情况

```class Solution {
public:
    bool isPerfectSquare(int num) {
        if(num<=1)
            return true;
        int left = 1;
        int right = num/2;
        while(left<=right){
            int mid = left + (right-left)/2;
            if ( (long long) mid*mid==num)
                return true;
            else if ((long long) mid*mid<num)
                {
                    left = mid+1;
                    
                }
            else if ((long long )mid*mid>num)
            {
                right=mid-1;
                
            }
        }
        return false;

    }
};
```

### 744. 寻找比目标字母大的最小字母

- 通过二分法确定目标的右边界，返回右边界后的值即可
- 临界处理： 当目标大于序列内的所有字母时，由于题中规定字母是循环，这种情况直接返回第一个值即可

```class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int left = 0;
        int right = letters.size()-1;
        while (left<=right){
            int mid = left +(right-left)/2;
            if(letters[mid]==target)
                left=mid+1;
            else if(letters[mid]>target){
                right=mid-1;
            }
            else if(letters[mid]<target)
            {
                    left=mid+1;      
            }
        }
        if (right+1<letters.size())
            return letters[right+1];
        else
            return letters[0];

    }
};
```