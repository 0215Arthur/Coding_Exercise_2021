- 排序与搜索

### 88.合并两个有序数组

- 跟之前做的合并两个有序链表有相同之处： 双指针加最后未遍历的部分
- 题目中给定nums1和nums2两个表，要求合并到第一个表并返回。
- 基础做法：合并后排序
- 常见做法：双指针从头到尾遍历，只不过要提前copy nums1中数据。 时间复杂度O(m+n) 空间复杂度O(m)

```class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int idx1=0;
        int idx2=0;
        int ids=0;
        vector<int> nums_copy(m);
        for(int i=0;i<m;i++){
            nums_copy[i]=nums1[i];
        }
        while(idx1<m && idx2<n){

            if(nums_copy[idx1]<nums2[idx2]){
                nums1[ids]=nums_copy[idx1];
                idx1++;
            }
            else{
                nums1[ids]=nums2[idx2];
                idx2++;
            }
            ids++;
        }
        
        while(idx1<m){
            nums1[ids++]=nums_copy[idx1++];
        }
        while(idx2<n){
            nums1[ids++]=nums2[idx2++];
        }
  
    }
};
```
- **进阶做法**  改变遍历顺序，从尾到头，由于nums1提前在尾部预留了填充位，因此这样做不需要额外空间
```class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int idx1=m-1;
        int idx2=n-1;
        int ids=m+n-1;
        while(idx1>=0&&idx2>=0){
            
            nums1[ids--]=(nums1[idx1]>nums2[idx2])?nums1[idx1--]:nums2[idx2--];

        }
        while(idx2>=0)
        {
            nums1[ids--]=nums2[idx2--];
        }

    }
};
```

- **更精简的写法**  将最后的未遍历的部分加入主循环中，改变循环停止条件
```class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int tail=m+n-1,tail1=m-1,tail2=n-1;
        while(tail!=tail1)
        {
            if(tail1>=0 && nums1[tail1]>nums2[tail2]) nums1[tail--]=nums1[tail1--];
            else nums1[tail--]=nums2[tail2--];
        }
    }
};
```