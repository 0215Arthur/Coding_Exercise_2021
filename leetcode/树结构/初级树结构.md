



树比链表稍微复杂，因为链表是线性数据结构，而树不是。 
树的问题可以由 广度优先搜索BFS 或 深度优先搜索DFS 解决。 

重点题目：
二叉树的最大深度，
验证二叉搜索树，
二叉树的层次遍历 和 将有序数组转换为二叉搜索树

- 主要要掌握：
  - 二叉树的遍历方式BFS、DFS，
  - 以及对应的先序(根-左-右)/中序(左 根 右)/后序(左 右 根)/层级遍历
  - 中序遍历与二叉搜索树对应(BST)

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [树的遍历不同方式](#树的遍历不同方式)
  - [先序遍历](#先序遍历)
  - [中序遍历 L Root R](#中序遍历-l-root-r)
  - [后序遍历 L R root](#后序遍历-l-r-root)
- [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
- [递归解二叉树问题模板](#递归解二叉树问题模板)
  - [自顶而下](#自顶而下)
  - [自底而上](#自底而上)
- [104. 二叉树的最大深度](#104-二叉树的最大深度)
- [98. 验证二叉搜索树 [KEY]](#98-验证二叉搜索树-key)
- [101. 对称二叉树](#101-对称二叉树)
- [108. 有序数组转搜索二叉树 [KEY]](#108-有序数组转搜索二叉树-key)
- [路径总和](#路径总和)
- [从中序和后序中构建二叉树](#从中序和后序中构建二叉树)
- [先序加中序构建二叉树](#先序加中序构建二叉树)
- [填充每个节点的下一个右侧节点指针](#填充每个节点的下一个右侧节点指针)

<!-- /code_chunk_output -->

### 树的遍历不同方式

#### 先序遍历
```
class Solution {
    vector<int> res;
public:
    void preoderTrav(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        res.push_back(root -> val);
        preoderTrav(root -> left);
        preoderTrav(root -> right);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        preoderTrav(root);
        return res;
    }
};
```
- **迭代方式进行:基于栈实现，首先将left节点压到低，然后开始进行节点弹出，并转换到右子树**

```
class Solution {
    vector<int> res;
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        while (!st.empty() || root != nullptr) {
            while (root) {
                res.push_back(root -> val);
                st.push(root);
                root = root -> left;
            }
            root = st.top();
            st.pop();
            root = root -> right;
        }
        return res;
    }
};
``` 
#### 中序遍历 L Root R
- 迭代方式：
```
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        while (!st.empty() || root != nullptr) {
            while (root) {
                st.push(root);
                root = root -> left;
            }
            root = st.top();
            res.push_back(root -> val);
            st.pop();
            root = root -> right; 
        }
        return res;
    }
};
```
#### 后序遍历 L R root
- 递归方式
```
class Solution {
public:
    vector<int> res;
    void postorderTrav(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        postorderTrav(root -> left);
        postorderTrav(root -> right);
        res.push_back(root -> val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        postorderTrav(root);
        return res;
    }
};
```

- 迭代方式: 稍微复杂一点，要考虑到左子树遍历完成后，右子树是否有节点，
```
class Solution {
public:
    vector<int> res;
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode* > st;
        TreeNode* prev = nullptr;
        while (!st.empty() || root != nullptr) {
            while (root) {
                st.push(root);
                root = root -> left;
            }
            root = st.top();
            st.pop();  
            // 右边为空 或者之前已经遍历过了，则就不再深入，直接把当前root添加入res中
            if (root -> right == nullptr || root -> right == prev) {
                res.push_back(root -> val);
                prev = root;
                root = nullptr;
            }
            // 右边还是具有节点的，那么调整方面继续入栈
            else {
                st.push(root);
                root = root -> right;
            }
        }
        return res;
    }
};
```

### 102. 二叉树的层序遍历

- 最简单的做法：利用BFS做层序遍历，利用队列存储节点指针，每层运算结束时记录当前层的数组
```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root==NULL) return res;
        queue<TreeNode*>Q;
        Q.push(root);
       
        while(Q.size()>0){
            
            vector<int> tmp;
            int sz=Q.size();
            while(sz){
                TreeNode * node=Q.front();
                Q.pop();
                if(node->left){
                    Q.push(node->left);
                }
                if(node->right){
                    Q.push(node->right);
                }
                tmp.push_back(node->val);
                sz--;
            }
            res.push_back(tmp);
            
        }
        return res;
    }
};

```
- 递归方式： 利用DFS的思想进行遍历，并根据遍历的深度存储数组：利用先序遍历的方式完成任务，只是额外添加了遍历层数，使得能够记录数字对应的层数；
![avatar](102.png)
![avatar](102-02.png)
```
class Solution {
public:
    vector<vector<int>> res;
    void _level(TreeNode* root,int level){
        if(root==NULL) return;
        if(level>=res.size()){
            res.push_back(vector<int>()); //提前添加空数组
        }
        res[level].push_back(root->val);
        _level(root->left,level+1);
        _level(root->right,level+1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        _level(root,0);  
        return res;
    }
};
```

### 递归解二叉树问题模板
#### 自顶而下
- 在递归中先更新结果或者目标信息， 与先序遍历相似，*先记录结果当前结果*
  - 能确定一些参数，从**该节点自身解决出发**寻找答案吗？
  - 可以使用这些参数和节点本身的值来**决定什么应该是传递给它子节点的参数**吗？
```
1. return specific value for null node
2. update the answer if needed                      // answer <-- params
3. left_ans = top_down(root.left, left_params)		// left_params <-- root.val, params
4. right_ans = top_down(root.right, right_params)	// right_params <-- root.val, params
5. return the answer if needed 
```
#### 自底而上
- 对所有子节点递归调用函数，根据返回值和节点信息得到答案，即自底而上，类似于后序遍历
- 对于树中的任意一个节点，如果知道它子节点的答案，就能计算出该节点的答案
```
1. return specific value for null node
2. left_ans = bottom_up(root.left)			// call function recursively for left child
3. right_ans = bottom_up(root.right)		// call function recursively for right child
4. return answer
```
### 104. 二叉树的最大深度

- 二叉树遍历问题： BFS/DFS
- 基于DFS思想，计算左右子树的深度，取两子树的最大深度; 时间复杂度O(n) 空间复杂度O(depth)

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==NULL){
            return 0;
        }
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```
- 基于自顶而下的递归思想
```
class Solution {
public:
    int ans = 0;
    void dfs(TreeNode* root, int depth) {
        if (root == nullptr)
            return;
        if (!root -> left && !root -> right )
            ans = max(ans, depth);
        dfs(root -> left, depth + 1);
        dfs(root -> right, depth + 1);
    }
    int maxDepth(TreeNode* root) {
        if (!root) 
            return 0;
        dfs(root, 0);
        return ans + 1;

    }
};
```
- 基于BFS思想，每遍历树一层，深度就加1，当BFS完成整个树即得到最终的结果；
     时间复杂度O(n) 空间复杂度O(n)

```
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==NULL) return 0;
        int depth=0;
        queue<TreeNode*> q;
        q.push(root);
        while(q.size()>0){
            int s=q.size();
            // 当前层出队，并将下一层节点加入
            while(s){
                TreeNode* node=q.front();
                q.pop();
                if(node->left){
                    q.push(node->left);
                }
                if(node->right){
                    q.push(node->right);
                }
                s-=1;
            }
            depth++;
        }
        return depth;
    }
};
```
![avatar](./dfs-0.png)
![avatar](./dfs-1.png)

### 98. 验证二叉搜索树 [KEY]

- 涉及基本的二叉树遍历以及二叉搜索树性质

- 递归解法: 利用BST所有左子树节点小于根节点，所有右子树节点大于根节点，这一性质构建递归公式

```/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper){
        if(root==NULL) return true;

        if(root->val<=lower||root->val>=upper){
            return false;
        }
        return helper(root->left,lower,root->val)&&helper(root->right,root->val,upper);

    }
    bool isValidBST(TreeNode* root) {
        return helper(root,LONG_MIN,LONG_MAX);
        }
};
```

- 遍历解法：利用**中序遍历**得到BST对应的数组，检查是否是单增的数组即可
![avatar](./inorder-0.png)
```/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> nodes;
    // 中序遍历
    void inOrderParse(TreeNode* root){
        if(root==NULL) return;
        inOrderParse(root->left);
        nodes.push_back(root->val);
        inOrderParse(root->right);
    }
    bool isValidBST(TreeNode* root) {
        inOrderParse(root);
        for(int i=0;i<nodes.size()-1;i++){
            if(nodes[i+1]<=nodes[i]){
                return false;
            }
        }
        return true;
        }
      
};
```

### 101. 对称二叉树

- 利用迭代的方式实现：**记录双指针**，指针方向相反同时压入队列，使得队列中连续两个指针值相同；否则为非对称树
![avatar](./sysm-0.png)
```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode*> Q;
        Q.push(root);
        Q.push(root);
        while(Q.size()>0){
            TreeNode* p= Q.front(); Q.pop();
            TreeNode* q= Q.front(); Q.pop();
            if(!p&&!q){
                continue;
            }
            else if(!p || !q){
                return false;
            }
            if(p->val!=q->val){
                return false;
            }
            Q.push(p->left);
            Q.push(q->right);
            Q.push(p->right);
            Q.push(q->left);
        }
        return true;
        
    }
};
```

- 递归方式：跟上面一样利用**双指针**，向着对称的相反方向进行遍历：
```class Solution {
public:
    bool check(TreeNode*p, TreeNode*q){
        if(!p&&!q) return true; // 
        if(!p||!q) return false; // 非对称情况
        return (p->val==q->val)&&(check(p->left,q->right))&&(check(p->right,q->left)); 
    }
    bool isSymmetric(TreeNode* root) {
       return  check(root,root);
    }
};
```

### 108. 有序数组转搜索二叉树 [KEY]

- 要求左右子树高度平衡，即需要选择数组中间位置的数字作为根节点
    当数组长度为奇数或者偶数时，存在差异：对于偶数时需要考虑选择偏左位置还是偏右位置的作为根节点，两者没有效果差异
- 通过递归形式，进行转换

```class Solution {
public:
    TreeNode * helper(vector<int>& nums, int left,int right){
        if(left>right){
            return NULL; 
        }
        int mid=int((left+right+1)/2);

        TreeNode * root=new TreeNode(nums[mid]);
        root->left=helper(nums,left,mid-1);
        root->right=helper(nums,mid+1,right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(nums,0,nums.size()-1);

    }
};

```
![avatar](./108-01.png)

### 路径总和
- 递归解法; 时间复杂度 O(N) 空间复杂度 O(H)
```
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) 
            return false;
        if (root -> left == nullptr && root -> right == nullptr) {
            return root -> val == targetSum;
        }
        return hasPathSum(root -> left, targetSum - root->val) || hasPathSum(root -> right, targetSum - root->val);
    }
};
```
- 迭代解法： **与通用bfs相比，需要增加一个队列记录当前路径的总和**
- 时间复杂度 O(N)； 空间复杂度 O(N)
```
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root)
            return false;
        queue<TreeNode*> q;
        queue<int> qv; // 增加一个队列来记录求和情况
        qv.push(root -> val);
        q.push(root);
        while (!q.empty()) {
            int q_size =  q.size();
            for (int i = 0; i < q_size; i++) {
                TreeNode* cur = q.front();
                q.pop();
                int tmp = qv.front();
                qv.pop();
                if (!cur -> left && !cur -> right) {
                    if ( tmp == targetSum) {
                        return true;
                    }
                }
                if (cur -> left) {
                    q.push(cur -> left);
                    qv.push(cur -> left -> val + tmp);
                }
                if (cur -> right) {
                    q.push(cur -> right);
                    qv.push(cur -> right -> val + tmp);
                }
            }
        }
         return  false;
    }
};
```

### 从中序和后序中构建二叉树
- 寻找根节点位置，并确定根节点在何处划分左右子树
- 主要注意遍历方向
```
class Solution {
public:
    unordered_map<int, int> idx_map;
    int post_idx = 0;
    TreeNode* helper(int in_left, int in_right, vector<int>& inorder, vector<int>& postorder) {
        if (in_left > in_right)
            return nullptr;
        //cout << post_idx <<endl;
        int val = postorder[post_idx]; //根节点val
        TreeNode* root = new TreeNode(val); //创建根节点
        int in_idx = idx_map[val]; //获取左右子树分割索引
        post_idx--; //后序数组下移到下个子根节点
        
        // 后序数组从后遍历是先根 后右节点，因此在dfs部分要先进右分支！！！
        root -> right = helper(in_idx + 1, in_right, inorder, postorder); //先dfs走向右子树方向
        root -> left = helper(in_left, in_idx - 1, inorder, postorder);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); i++) {
            idx_map[inorder[i]] = i;
        }
        post_idx = postorder.size() - 1;
        TreeNode* root = helper(0, post_idx, inorder, postorder);
        return  root;
    }
};
```

### 先序加中序构建二叉树

- 构建方法：根据先序数组获得根节点值，并对中序数组建立节点值-索引的哈希表
- 每次从先序表中取root值，然后对应的从中序表中获取对应的索引，从而得到划分左右子树的index
- 直接根据root值创建节点，并基于index进行左右子树的创建递归
- **根据先序数组的顺序（root，left，right），正向递归时先进left分支**
- 时间复杂度O(N)，空间复杂度O（N）

```
class Solution {
public:
    unordered_map<int, int> idx_map;
    int pre_idx;
    TreeNode* helper(int in_left, int in_right, vector<int>& preorder, vector<int>& inorder) {
        if(in_left > in_right) {
            return nullptr;
        }
        int val = preorder[pre_idx];
        TreeNode* root = new TreeNode(val);
        int index = idx_map[val];
        pre_idx++;
        root -> left = helper(in_left, index - 1, preorder, inorder);
        root -> right = helper(index + 1, in_right, preorder, inorder);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); i++) {
            idx_map[inorder[i]] = i;
        }
        pre_idx = 0;
        return helper(0, preorder.size() - 1, preorder, inorder);
    }
};
```

### 填充每个节点的下一个右侧节点指针

- 递归法，自顶而下的方法
- **因为是完全二叉树**，可以将节点的左右子节点进行连接
```
class Solution {
public:
    void dfs(Node* left, Node* right) {
        if (left == nullptr || right == nullptr) {
            return;
        }
        left -> next = right;
        dfs(left -> left, left -> right);
        dfs(right -> left, right -> right);
        dfs(left -> right, right -> left);
    }
    Node* connect(Node* root) {
        if (!root) {
            return root;
        }
        if (root -> left && root -> right) {
            dfs(root -> left, root -> right);
        }
        return root;
    }
};
```
