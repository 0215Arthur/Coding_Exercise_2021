
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [344.反转字符串](#344反转字符串)
- [7. 整数反转](#7-整数反转)
- [387. 字符串中的唯一字符](#387-字符串中的唯一字符)
- [字符的有效异位符](#字符的有效异位符)
- [125. 回文串验证](#125-回文串验证)
- [8.字符串转换整数 (atoi) Mid](#8字符串转换整数-atoi-mid)
- [8. 实现strStr() 子串匹配查找](#8-实现strstr-子串匹配查找)
- [38.外观数列](#38外观数列)
- [14. 最长公共前缀](#14-最长公共前缀)
- [49. 字母异位词组合](#49-字母异位词组合)
- [3. 无重复字符的最长子串 [Medium] [Tencent]](#3-无重复字符的最长子串-medium-tencent)
- [5. 最长回文子串 [Medium] [ByteDance]](#5-最长回文子串-medium-bytedance)
- [334. 递增的三元子序列 [Medium]](#334-递增的三元子序列-medium)
- [224. 基础计算器 [Hard] ***](#224-基础计算器-hard-)
- [227. 基本计算器II [Medium]](#227-基本计算器ii-medium)

<!-- /code_chunk_output -->

### 344.反转字符串

- 双指针法：头尾指针进行掉换，时间复杂度为O(N)

```
class Solution {
public:
    void reverseString(vector<char>& s) {
        int start=0;
        int end=s.size()-1;
        while(start<end){
            int tmp=s[start];
            s[start]=s[end];
            s[end]=tmp;
            start++;
            end--;
        }

    }
};
```


### 7. 整数反转

- 将有符号的整数(int32)进行反转
- 主要考虑反转过程的溢出情况：当数是正数，逐步计算反转值使用 res*10+pop; 当上一步得到的res以及接近最大临界时需要提取return: res>INT_MAX/10 （res==INT_MAX/10&&res>7） 7为最大正整数的个位数
- 时间复杂度O(log10(x)) 要处理log10(x)个数字

```class Solution {
public:
    int reverse(int x) {
       int res=0;
        while(x){
            int pop=x%10;
            if(res>INT_MAX/10||(res==INT_MAX/10 && pop>7 )) return 0;
            if(res<INT_MIN/10||(res==INT_MIN/10 && pop<-8 )) return 0;
            x=int(x/10);
            res=res*10+pop;
        }
        return res;
    }
};
```


###  387. 字符串中的唯一字符

- 返回字符串中第一个出现的非重复字符
- 使用哈希表记录各字符的情况，最后再遍历一遍字符串得到第一个非重复字符

```
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<char,int> keys;
        for(int i=0;i<s.length();i++)
        {
            keys[s[i]]++;
        }
        int pos=0;
          for(int i=0;i<s.length();i++)
        {
            if(keys[s[i]]==1)
             return i;
        }
        return -1;

    }
};
```

### 字符的有效异位符

- 判断两个字符串是否为字符异位符  即字符分布相同，位置不同；
- 对字符串进行排序，然后比较: 时间复杂度排序:O(nlogn)
- 哈希表记录字符串内的数字分布情况，判断两个字符串是否相同： 时间复杂度O(n)


```
class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(),s.end());
        sort(t.begin(),t.end());
        if(s==t)
        return true;
        return false;

    }
};
```

```class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
        return false;
        unordered_map<char,int> keys;
        for(int i=0;i<s.length();i++){
            keys[s[i]]++;
        }
        for(int i=0;i<t.length();i++){
            if(keys.count(t[i])==0)
              return false;
            keys[t[i]]--;
            if(keys[t[i]]==0)
             keys.erase(t[i]);
        }
        return true;
        

    }
};
```

###  125. 回文串验证

- 要剔除非字母/数字的字符
- 可以利用双指针法进行剔除和回文的同时验证；(注意大小字母转换)  时间复杂度O(|s|) 空间复杂度O(1)
- 或者将剔除的字符放在新的字符串中，利用字符串反转等操作进行回文判断 O(|s|) 空间复杂度O(|s|)

```
class Solution {
public:
    bool isPalindrome(string s) {
        int start=0;
        int end=s.length()-1;
        //cout<<end<<endl;
        while(start<end){
            if((s[start]<'a'||s[start]>'z')&&(s[start]<'0'||s[start]>'9')&&(s[start]<'A'||s[start]>'Z'))
            {
                start++;continue;
            }
            
            if((s[end]<'a'||s[end]>'z')&&(s[end]<'0'||s[end]>'9')&&(s[end]<'A'||s[end]>'Z'))
            {
                end--;continue;
            }
            if(tolower(s[start])!=tolower(s[end]))
            return false;
            start++;
            end--;
        }
        return true;

    }
};
```

### 8.字符串转换整数 (atoi) Mid

- 字符串转换需要考虑比较多的边界情况，可以考虑使用有限状态自动机来解题
- 注：当题目中的情况比较多，即需要考虑特别多/细小的边界情况，需要联想到使用自动机来简化解题过程。
- 对于越界情况，可以简化使用Long long形态来简化

```
class Solution {
public:
    int myAtoi(string s) {
        int res=0;
        bool begin=false;
        int sign=1;
        for(int i=0;i<s.size();i++){
           
            if(s[i]==' ') 
            {
                if(begin)
                  return res;
                continue;
            }

            // 判断第一个valid
            if((s[i]!='-')&&(s[i]!='+')&&(s[i]<'0')||(s[i]>'9')){
                return res;
            }
            if(s[i]=='-'){
                sign=-1;
                if(begin) return res;
                begin=true;
            }
            else if(s[i]=='+'){
                if(begin) return res;
                begin=true;
                continue;
            }
            else{
                begin=true;
                //*sign;
                if((res>INT_MAX/10)||(res==INT_MAX/10&&s[i]>'7')){
                    
                    return INT_MAX;
                }
                if(res<INT_MIN/10||(res==INT_MIN/10&&(s[i]-'0')>8)){
                    return INT_MIN;
                }
                int tmp=res*10;
                cout<<tmp<<endl;
                res=tmp+(s[i]-'0')*sign;
                cout<<res<<endl;
            }
        }
        return res;

    }
};
```

### 8. 实现strStr() 子串匹配查找

- KMP查找算法，定义最大相同前后缀长度，计算子串各位置的最大前缀长度，当出现不匹配时根据最大前缀长度进行回退 时间复杂度(O(N))
- 常见面试题，需要深入了解并记住该原理，可以动态规划求解：前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串
- 字符串匹配算法：还有Sunday 匹配机制相对比较简单：
    - 

```
class Solution {
public:
    void get_next(vector<int> &next,string &s){
        int j=-1;
        next[0]=j;
        for(int i=1;i<s.length();i++){
            //回溯
            while(j>=0&&s[j+1]!=s[i])
            {
                j=next[j];
            }
            if(s[j+1]==s[i]){
                j++;
            }
            next[i]=j;
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.length()==0) return 0;
        vector<int> next(needle.length());
        get_next(next,needle);
        int j=-1;
        for(int i=0; i<haystack.length();i++){
            int ns=0;
            while(j>=0&&haystack[i]!=needle[j+1]){
                j=next[j];
            }
            if(haystack[i]==needle[j+1]){
                j++;
            }
            
            if(j==needle.size()-1)
            return (i-needle.size()+1);
            
        }
    return -1;
    }
};
```

- 更简单的匹配方法：记录待匹配子串的位移表，即每一个在子串 中出现的字符，在子串中出现的最右位置到尾部的距离+1，即记录在匹配失败后的最小移动长度
- 在匹配失败后根据位移表，调整目标串的遍历指针位置，如果下个字符出现在子串中，根据位移表进行指针移动；否则直接将位置移动len+1个位置。
- 时间复杂度O(n)，最差情况：O(mn)
```
class Solution {
public:
    
    int strStr(string haystack, string needle) {
        if(needle.length()==0) return 0;
        unordered_map<int,int> shift;
        int len=needle.length();
        for(int i=len-1;i>=0;i--){
            if(shift.count(needle[i]))
            continue;
            shift[needle[i]]=len-i;
        }
        int ns=0;
        int start=0;
        int i=start;
        while( i<haystack.length()){
            if(haystack[i]!=needle[ns]){
                if(start+len<haystack.length()){
                    if(shift.count(haystack[start+len])){
                        start=start+shift[haystack[start+len]];
                    }else{
                        start=start+len+1;
                    }
                    i=start;
                }
                else{
                    return -1;
                }
                ns=0;
            }
            else{
                ns++;
                i++;
                if(ns==needle.length()){
                    return start;
                }
            }
        }

    return -1;
    }
};
```

### 38.外观数列
- 数组遍历，分段计算
- 可以使用双指针完成，头尾指针共同确定一段数字相同的片段

```class Solution {
public:
    string countAndSay(int n) {
        if(n==1) return "1";
        
        string s=countAndSay(n-1);
        int counts=1;
        string res;
        char tmp;
        
        for(int i=0;i<s.length();i++){
            if(i==0){
                counts=1;
                tmp=s[i];
                if(i==s.length()-1){
                res.append(to_string(counts));
                counts=1;
                res.append(1,tmp);
                tmp=s[i]; 
                }
                continue;
            }
            if(s[i]==s[i-1]){
                counts++;
            }else{
                res.append(to_string(counts));
                counts=1;
                res.append(1,tmp);
                tmp=s[i];
            }
            if(i==s.length()-1){
                res.append(to_string(counts));
                counts=1;
                res.append(1,tmp);
                tmp=s[i]; 
            }
            //cout<<res<<endl;
        }

        return res;

    }
};
```


### 14. 最长公共前缀

- 计算多个字符串的最长公共前缀
- 基本方法包括：横向扫描方法和纵向扫描方法
    - 横向扫描：对于m个字符串，依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。
    $LCP(S_1,S_2...,S_n)=LCP(LCP(...LCP(LCP(S_1,S_2),S_3)..))$   
    时间复杂度：O(mn) 空间复杂度：O(1)

    - 纵向扫描: 最容易想到，逐一遍历各串同一位置上的字符，对比是否相同，如不同或者达到字符尾，扫描结束。  时间复杂度：O(mn) 空间复杂度：O(1)

- 二分查找：长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用 $\textit{minLength}minLength$ 表示字符串数组中的最短字符串的长度，则可以在 $[0,\textit{minLength}][0,minLength]$ 的范围内通过二分查找得到最长公共前缀的长度。
每次取查找范围的中间值 $\textit{mid}mid$，判断每个字符串的长度为$ \textit{mid}mid$ 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 $\textit{mid}mid$，如果不相同则最长公共前缀的长度一定小于 $\textit{mid}mid$，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。  时间复杂度为O(mnlogm) m为最小字符串长度。


```
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        //int s_id=0;
        int c_id=0;
        char tmp;
        string res="";
        int s_len=strs.size();
        bool flag=false;
        if(s_len==0) return res;
        while(true){
            for(int i=0;i<s_len;i++){
                if(c_id==strs[i].length()){
                    flag=true;
                    break;
                }else{
                    if(i==0){
                        tmp=strs[i][c_id];
                    }else{
                        if(strs[i][c_id]!=tmp){
                            flag=true;
                            break;
                        }
                    }
                }

            }
            if(flag) return res;
            res.append(1,tmp);
            c_id++;
        }
        return res;


    }
};
```
### 49. 字母异位词组合
- 考察hash表的使用
- **两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同**。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表

```
class Solution {
public:
    unordered_map<string, vector<int>> maps;
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        for (int i = 0; i < strs.size(); i++) {
            string cur = strs[i];
            sort(cur.begin(), cur.end());
            if (!maps.count(cur)) {
                vector<int> tmp;
                tmp.push_back(i);
                maps[cur] = tmp;
            }
            else {
                maps[cur].push_back(i);
            }
        }
        vector<vector<string>> ans;
        for (unordered_map<string, vector<int>>::iterator iter = maps.begin(); iter != maps.end(); iter++) {
            vector<string> tmp;
            for (auto s : iter -> second) {
                tmp.push_back(strs[s]);
            }
            ans.push_back(tmp);
        }
        return ans;
    }
};
```


### 3. 无重复字符的最长子串 [Medium] [Tencent]
- 双指针/滑动窗口策略
- 仅遍历字符串一遍即可完成查找
  - 利用哈希表记录当前遍历字符，当出现重复字符时右指针停止遍历
  - 计算当前窗口大小，更新结果
  - 然后逐一移动左指针，将前一位结果从哈希表中移除，重复以上操作
  - 时间复杂度O(N) 空间复杂度O(N)
```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> seen;
        int right= 0;
        int ans = 0;
        int lens = s.size();
        for (int i = 0; i < lens; i++) {
            // 左指针逐步调整
            if (i != 0) {
                seen.erase(s[i - 1]);
            }
            // 右指针移动
            while (right < lens && !seen.count(s[right])) {
                seen.insert(s[right]);
                right++;
            }
            ans = max(ans, right - i);
        }
        return ans;
    }
};
```

### 5. 最长回文子串 [Medium] [ByteDance]
- 基础做法： 双指针中心展开方法进行回文子串搜索
  - 搜索回文子串时考虑是奇数还是偶数串
  - **特殊情况处理：** 考虑当回文子串长度为1时，需要进行返回
  - 时间复杂度O(N^2) 空间复杂度O(N)
```
class Solution {
public:
    string longestPalindrome(string s) {
        int maxLen = 1;
        string res;
        for (int i = 0; i < s.size() - 1; i++) {
            string odd = find(s, i, i);
            string even = find(s, i, i + 1);
            //cout << odd << endl;
            //cout << even << endl;
            string tmp = odd.size() > even.size() ? odd : even;
            if (tmp.size() > res.size())
                res = tmp;

        }
        if (res.empty()) {
            res = s.substr(0, 1);
        }
        return res;
    }
    string find(string s, int left, int right) {
        while(left >= 0 && right < s.size() && s[left] == s[right]) {
            left--;
            right++;
        }
        return s.substr(left + 1, right - left - 1);
    }

};
```

- **DP法解题**
  - 状态转移方程：`P[i,j`P(i,j)=P(i+1,j−1)∧(Si==Sj)
  - `P[i,i] = true` `P[i,i+1]=(Si==Sj)`
  - 时间复杂度 O(N^2) 空间复杂度 O(N^2)
  - 总体不如双指针中心扩展来的快
```
class Solution {
public:
    string longestPalindrome(string s) {
        int maxLen = 1;
        int begin = 0;
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n)); //初始化状态表
        for (int j = 1; j < n; j++) {
           // dp[j][j] = 1;
            for (int i = 0; i < j; i++) {
                if (s[j] == s[i]) {
                    if (j - i < 3) {
                        dp[i][j] = 1;
                    } else{
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                else {
                    dp[i][j] = 0;
                }
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, maxLen);
    }
   
};
```

### 334. 递增的三元子序列 [Medium] 
- 需要找出当前序列中的三个元素，满足递增性质
- 在遍历中存储top2值，来完成三元自序列的判断
- 即存在两级对比，时间复杂度 O(N)
  - 若是4元子序列呢？三次对比？
```
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int min = INT_MAX;
        int big = INT_MAX;
        // 两级对比
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > big) {
                return true;
            }
            else if (nums[i] > min) {
                big = nums[i]; 
            }
            else {
                min = nums[i];
            }
        }
        return false;

    }
};
```
### 224. 基础计算器 [Hard] ***
- 实现具有加减功能的计算器，考虑`+-` `()`括号的影响
- **基于栈的结构进行实现**
- 逻辑上，加减需要记录其对应的符号即可
- 其他复杂的部分在括号的处理，在进入括号时需要利用栈保存之前的数据状态，包括sign和结果，并重置目前状态
  - 最后遇到右括号时，进行出栈操作，进行结果恢复和更新
  
```
class Solution {
public:
    int calculate(string s) {
        stack<int> st;
        int num = 0;
        int  sign = 1;
        int res = 0;
        for (int i = 0; i < s.size(); i++) {
            char c = s[i];
            if (isdigit(c)) {
                num = num * 10 + (c - '0');
            }
            if (c == '+' || c == '-') {
                // 计算上一个值的情况 sign记录当前的符号
                res += sign * num;
                num = 0;
                // 更新符号
                sign = c == '+' ? 1 : -1; 
            }
            else if (c == '(') {
                // 入栈操作 存储之前的res和符号
                st.push(res);
                st.push(sign);
                res = 0; // 状态重置
                sign = 1; //  状态重置
            }
            else if (c == ')') {
                res += num * sign;
                
                res *= st.top(); // 出栈 之前记录的sign
                st.pop();
                res += st.top();
                st.pop();
                num = 0;
            }
        }
        // 不要忽略最后一个数
        res += sign*num;
        return res;
    }
};
```

### 227. 基本计算器II [Medium]

- 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分
  - 包括 + - * / ，**不包含括号**
  - 使用栈进行简单存储即可，没有括号的情况下要比上题简单多

- 将数字和其对应的符号运算后存入stack，最后计算stack元素之和即可
  - 其中 `*` `/` 处理需要取stack的栈顶与当前元素进行计算
  - 再运算结合需要更新当前num和符号信息

```
class Solution {
public:
    int calculate(string s) {
        stack<int> st;
        char sign = '+';
        int num = 0;
        for (int i = 0; i < s.size(); i++) {
            char c = s[i];
            if (isdigit(c)) {
                num = num * 10 + (c - '0');
            }
            // 临界情况： 当遍历到最后一个字符时，如果最后一个字符还是数字的话，还是要做处理
            if( !isdigit(c) && c != ' ' || i == s.size() - 1) {
                if (sign == '+') {
                    st.push(num);
                    sign = 1;
                }
                else if (sign == '-') {
                    st.push(-num);
                }
                else if (sign == '/') {
                    int a = st.top();
                    st.pop();
                    st.push(a / num);
                }
                else if (sign == '*') {
                    int a = st.top();
                    st.pop();
                    st.push(a * num);   
                }
                // 更新当前数字和符号
                num = 0;
                sign = c;
            } 
        }
        int ans = 0;
        while (!st.empty()) {
            ans += st.top();
            st.pop();
        }
        return ans;
    }
};
```